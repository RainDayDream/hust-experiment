# 两道题目思路

**CS2009_U202015562_徐雨梦**

## 题目一

题目：实训三的第17关

​	查询2022年2月购买基金的高峰期。至少连续三个交易日，所有投资者购买基金的总金额超过100万(含)，则称这段连续交易日为投资者购买基金的高峰期。只有交易日才能购买基金,但不能保证每个交易日都有投资者购买基金。2022年春节假期之后的第1个交易日为2月7日,周六和周日是非交易日，其余均为交易日。请列出高峰时段的日期和当日基金的总购买金额，按日期顺序排序。总购买金额命名为amount。

**思路：**

**高峰期有以下三种情况：**

- **该天交易超过100万，且该天前两天为周六和周日或者交易超过100万**
- **该天交易超过100万，且该天后两天为周六和周日或者交易超过100万**
- **该天交易超过100万，且前一天为周日或交易超过100万并且后一天为周六或交易超过100万**

**因此，从表中先筛选出来2月份交易超过100万的日期，再从其中筛选出来这三种情况的表再通过UNION结合起来就可以得到所有的2月份的高峰交易日即可。**

**具体的在代码中有所注释。**

代码：

```
-- 17 查询2022年2月购买基金的高峰期。至少连续三个交易日，所有投资者购买基金的总金额超过100万(含)，则称这段连续交易日为投资者购买基金的高峰期。只有交易日才能购买基金,但不能保证每个交易日都有投资者购买基金。2022年春节假期之后的第1个交易日为2月7日,周六和周日是非交易日，其余均为交易日。请列出高峰时段的日期和当日基金的总购买金额，按日期顺序排序。总购买金额命名为total_amount。

WITH T1 AS
(SELECT pro_purchase_time,SUM(pro_quantity*f_amount) amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING amount>1000000 AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time),
T2 AS
(SELECT pro_purchase_time p_time,SUM(pro_quantity*f_amount) amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING amount>1000000 AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time)--T1,T2这两个表保存了二月份中基金购买金额在100万以上的日期和金额，不同点在于日期的名称不一样，方便后续进行比较
SELECT pro_purchase_time,amount FROM(
(SELECT pro_purchase_time,amount FROM T1 WHERE 
((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-2) OR (extract(dow from pro_purchase_time-2)=6) OR (extract(dow from pro_purchase_time-2)=0))
AND
(EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-1) OR (extract(dow from pro_purchase_time-1)=6) OR (extract(dow from pro_purchase_time-1)=0)))--筛选情况1的数据。
)
UNION
(SELECT pro_purchase_time,amount FROM T1 WHERE
((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+1) OR (extract(dow from pro_purchase_time+1)=6) OR (extract(dow from pro_purchase_time+1)=0))
AND
(EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-1) OR (extract(dow from pro_purchase_time-1)=6) OR (extract(dow from pro_purchase_time-1)=0)))--筛选情况2的数据。
)
UNION
(SELECT pro_purchase_time,amount FROM T1 WHERE
((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+2) OR (extract(dow from pro_purchase_time+2)=6) OR (extract(dow from pro_purchase_time+2)=0))
AND
(EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+1) OR (extract(dow from pro_purchase_time+1)=6) OR (extract(dow from pro_purchase_time+1)=0)))--筛选情况3的数据。
)
) ORDER BY pro_purchase_time;--对筛选出来的数据进行排序
```

## 题目二

题目：实训6的第2关

​	医院的某科室有科室主任1名(亦为医生)，医生若干(至少2名，不含主任)，护士若干(至少4人)，现在需要编写一存储过程，自动安排某个连续期间的大夜班(即每天00:00-8:00时间段)的值班表，排班规则为： 1.每个夜班安排1名医生，2名护士； 2.值班顺序依工号顺序循环轮流安排(即排至最后1名后再从第1名接着排)； 3.科室主任参与轮值夜班，但不安排周末(星期六和星期天)的夜班，当周末轮至科主任时，主任的夜班调至周一，由排在主任后面的医生依次递补值周末的夜班。

​	存储过程的名字为sp_night_shift_arrange,它带两个输入参数：start_date, end_date，分别指排班的起始时间和结束时间。排班结果直接写入表night_shift_schedule

**思路：**

​	**医生的排班需要在周末跳过主任，而护士的排班没有特殊情况。**

**对于护士排班：**

​	**只需要让游标从头开始读，每排一天的班就读两次即可。但是在读的时候需要判断当前游标是否已经读完了，如果读完了就需要关闭游标再打开从头再读。**

**对于医生排班：**

​	**周六周日主任不值班延后到周一，因此周六、周日、周一是三个特殊的情况，需要特殊处理，其他的情况，也就是周二到周五，与护士排班的情况是相同的。因此首先从医护人员的表中读出主任的名字，以便后续做判断；同时还需要设置一个标志数据（初始化为0），来表示主任是否在周末被排到班而被跳过，以便周一做判断。**

​	**每插入一条数据，就需要判断当前的日期是周几：**

- **如果是周六/周日，将游标读取一条数据，判断该医生是否为主任，如果是，将设置标志数据为1，并再读取一条数据赋值给当天的值班医生数据，否则就直接将该数据赋值给当天的值班数据；**
- **如果是周一，将判断当前标志位是否为1，如果是，将直接把主任设置为该天的值班医生，否则游标读取一条数据赋值给当天的值班医生；**
- **如果不是周六/周日/周一，将直接利用游标读取一条数据赋值给当天的值班医生。**

**以上所有需要采用游标读取数据的地方都要判断当前是否为最后一条，如果是，就需要关闭游标再打开以从头开始读数据。**

代码：

```
-- 编写一存储过程，自动安排某个连续期间的大夜班的值班表:
create procedure sp_night_shift_arrange(in start_date date, in end_date date)
AS
CURSOR doctor FOR
select e_name from employee where e_type=1 or e_type=2 order by e_id;
CURSOR nurse FOR
select e_name from employee where e_type=3 order by e_id;
declare cur_date date;
declare doctor_name char(30);
declare nurse_name1 char(30);
declare nurse_name2 char(30);
declare doctor_type int;
declare flag int default 0;
declare zhou int;
declare zhuren char(30);

begin
    open doctor;
    open nurse;
    cur_date:=start_date;
    select e_name into zhuren from employee where e_type=1;
    while cur_date<=end_date loop
        zhou:=extract(dow from cur_date);--这一天是周几
        if zhou=0 or zhou=6 then--周六和周日判断当前是否是主任
            fetch doctor into doctor_name;--先找到这个人
            if doctor%notfound then --doctor已经遍历完了，就重头开始
                close doctor;
                open doctor;
                fetch doctor into doctor_name;
            end if;
            if doctor_name=zhuren then --如果是主任
                flag:=1;
                fetch doctor into doctor_name;--再找一个医生
                if doctor%notfound then --doctor已经遍历完了，就重头开始
                    close doctor;
                    open doctor;
                    fetch doctor into doctor_name;
                end if;
            end if;
        elseif zhou=1 then--如果是周一
            if flag=1 then 
                doctor_name=zhuren;--之前主任轮空，轮到主任
                flag=0;
            else 
                fetch doctor into doctor_name;--之前主任没有轮空
                if doctor%notfound then --doctor已经遍历完了，就重头开始
                    close doctor;
                    open doctor;
                    fetch doctor into doctor_name;
                end if;
            end if;
        else
            fetch doctor into doctor_name;--普通情况找一个医生
            if doctor%notfound then --doctor已经遍历完了，就重头开始
                close doctor;
                open doctor;
                fetch doctor into doctor_name;
            end if;
        end if;
        fetch nurse into nurse_name1;
        if nurse%notfound then--找护士1
            close nurse;
            open nurse;
            fetch nurse into nurse_name1;
        end if;
        fetch nurse into nurse_name2;
        if nurse%notfound then
            close nurse;
            open nurse;
            fetch nurse into nurse_name2;
        end if;
        insert into night_shift_schedule values(cur_date,doctor_name,nurse_name1,nurse_name2);
        cur_date:=cur_date::date+interval'1 D';
    end loop;
    close doctor;
    close nurse;
end;
/*  end  of  your code  */ 


/*值得注意的是下面的这种写法是不对的，游标到了结尾再fetch一下才能notfound（第一次的写法）
        if nurse%notfound then--找护士
            close nurse;
            open nurse;
        else
            fetch nurse into nurse_name1;
        end if;
        if nurse%notfound then
            close nurse;
            open nurse;
        else
            fetch nurse into nurse_name2;
        end if;
        insert into employee values(cur_date,zhou,doctor_name,nurse_name1,nurse_name2);
        cur_date:=cur_date::date+interval'1 D';*/