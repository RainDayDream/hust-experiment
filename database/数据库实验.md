# 数据库实验

以下为题目和代码（U202015562）

平台openguass

### 命令行连接数据库

```
gsql -h 127.0.0.1 -d postgres -U gaussdb -W'Passwd123@123'
```

## 数据库、表与完整性约束定义 Create

```
第一关
创建数据库：
CREATE DATABASE beijing2022;

第二关
创建表及主码约束
    CREATE TABLE t_emp
    (
        id INT PRIMARY KEY,
        name VARCHAR(32),
        deptid INT,
        salary FLOAT
    );

第三关
创建外码约束
    CREATE TABLE dept
    (
        deptNo INT PRIMARY KEY,
        deptName VARCHAR(32)
    );

    CREATE TABLE staff
    (
        staffNo INT PRIMARY KEY,
        staffName VARCHAR(32),
        gender CHAR(1),
        dob date,
        Salary numeric(8,2),
        deptNo INT,
        CONSTRAINT FK_staff_deptNo FOREIGN KEY(deptNo) REFERENCES dept(deptNo)
    );
    
第四关
创建check约束
CREATE TABLE products
(
    pid CHAR(10) PRIMARY KEY,
    name VARCHAR(32),
    brand CHAR(10),
    price INT
    CONSTRAINT CK_products_brand CHECK(brand in('A','B')),
    CONSTRAINT CK_products_price CHECK(price>0)
);

第五关
创建default约束
CREATE TABLE hr
(
    id CHAR(10) PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    mz CHAR(16) default('汉族')
);

第六关
创建unique约束
CREATE TABLE s
(
    sno CHAR(10) PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    ID CHAR(18) UNIQUE
);
```

## 表结构和完整性约束的修改 Alter

- 第一关

  修改表名

  ```
  ----请在以下空白处添加恰当的语句，将表名your_table更改为my_table:
  ALTER TABLE your_table RENAME TO my_table;
  ```

- 第二关

  添加与删除字段

  ```
  ----语句1：删除表orderDetail中的列orderDate
  ALTER TABLE orderDetail DROP orderDate;
  ----语句2：添加列unitPrice
  ALTER TABLE orderDetail ADD unitPrice NUMERIC(10,2);
  ```

- 第三关

  修改字段

  ```
  ----请在以下空白处添加适当的SQL语句，实现编程要求
  ----将QQ号的数据类型改为char(12);
  ----增加一列，列名为wechat，数据类型是char(12)。
  ALTER TABLE addressBook MODIFY QQ CHAR(12),
  ADD wechat CHAR(12);

- 第四关

  添加、删除与修改约束

  ```
  ---(1) 为表Staff添加主码
  ALTER TABLE Staff ADD PRIMARY KEY (staffNo);
  ---(2) Dept.mgrStaffNo是外码，对应的主码是Staff.staffNo,请添加这个外码，名字为FK_Dept_mgrStaffNo:
  ALTER TABLE Dept ADD CONSTRAINT FK_Dept_mgrStaffNo FOREIGN KEY (mgrStaffNo)REFERENCES Staff(staffNo);
  ---(3) Staff.dept是外码，对应的主码是Dept.deptNo. 请添加这个外码，名字为FK_Staff_dept:
  ALTER TABLE Staff ADD CONSTRAINT FK_Staff_dept FOREIGN KEY (dept) REFERENCES dept(deptno);
  ---(4) 为表Staff添加check约束，规则为：gender的值只能为F或M；约束名为CK_Staff_gender:
  ALTER TABLE Staff ADD CONSTRAINT CK_Staff_gender CHECK(gender = ANY (ARRAY['F'::bpchar, 'M'::bpchar]));
  ---(5) 为表Dept添加unique约束：deptName不允许重复。约束名为UN_Dept_deptName：
  ALTER TABLE Dept ADD CONSTRAINT UN_Dept_deptName UNIQUE (deptName);

## 数据查询 Select

本实训采用的是某银行的一个金融场景应用的模拟数据库，数据库中表，表结构以及所有字段的说明如下：

![表1](./image/%E8%A1%A81.png)

![表2](./image/%E8%A1%A82.png)

![表3](./image/%E8%A1%A83.png)

![表4](./image/%E8%A1%A84.png)

![表5](./image/%E8%A1%A85.png)

![表6](./image/%E8%A1%A86.png)



- 第一关

  查询客户主要信息

  **SELECT的用法**

  ``` 
  -- 1) 查询所有客户的名称、手机号和邮箱信息。查询结果按照客户编号排序。
  SELECT c_name,c_phone,c_mail FROM client ORDER BY c_id;

- 第二关

  查询邮箱为null的用户

  **WHERE的用法**

  ```
  -- 2) 查询客户表(client)中邮箱信息为null的客户的编号、名称、身份证号、手机号。
  SELECT c_id,c_name,c_id_card,c_phone FROM client WHERE c_mail IS NULL;

- 第三关

  查询既买了保险又买了基金的客户

  **采用了with来生成子表方便where查询，使用了exists**

  ```
  -- 3) 查询既买了保险又买了基金的客户的名称、邮箱和电话。结果依c_id排序
  WITH BAOXIAN AS (SELECT pro_c_id FROM property WHERE pro_type=2),LICAI AS (SELECT pro_c_id FROM property WHERE pro_type=3) SELECT c_name,c_mail,c_phone FROM client WHERE EXISTS (SELECT pro_c_id FROM BAOXIAN WHERE pro_c_id=client.c_id) AND EXISTS (SELECT pro_c_id FROM LICAI WHERE pro_c_id=client.c_id);

- 第四关

  办理了**储蓄卡**的用户信息

  ```
  -- 4) 查询办理了储蓄卡的客户名称、手机号、银行卡号。 查询结果结果依客户编号排序。
  SELECT c_name,c_phone,b_number FROM client,bank_card WHERE b_c_id=c_id AND b_type='储蓄卡';

- 第五关

  每份金额在3000-5000之间的理财产品

  ```
  -- 5) 查询理财产品中每份金额在30000～50000之间的理财产品的编号,每份金额，理财年限，并按照金额升序排序，金额相同的按照理财年限降序排序。
  SELECT p_id,p_amount,p_year FROM finances_product WHERE p_amount BETWEEN 30000 AND 50000 ORDER BY p_amount,p_year DESC;

- 第六关

  商品收益的众数

  **子查询的使用**

  ```
  -- 6) 查询资产表中所有资产记录里商品收益的众数和它出现的次数。
  WITH RESULT AS(SELECT pro_income,COUNT(pro_income) AS presence FROM property GROUP BY pro_income)
  SELECT pro_income,presence FROM RESULT WHERE presence=(SELECT MAX(presence)FROM RESULT);

- 第七关

  未购买任何理财产品的武汉居民

  **NOT EXISTS的使用**

  ```
  -- 7) 查询身份证隶属武汉市没有买过任何理财产品的客户的名称、电话号、邮箱。
  SELECT c_name,c_phone,c_mail FROM client WHERE c_id_card LIKE '4201%' AND NOT EXISTS (SELECT pro_c_id FROM property WHERE c_id=pro_c_id AND pro_type=1);

- 第八关

  持有两张信用卡的用户

  **聚集函数count的使用**

  ```
  -- 8) 查询持有两张(含）以上信用卡的用户的名称、身份证号、手机号。
  WITH BIAO AS(SELECT b_c_id FROM bank_card GROUP BY b_c_id,b_type HAVING COUNT(b_number)>=2 AND b_type='信用卡')
  SELECT c_name,c_id_card,c_phone FROM client WHERE EXISTS(SELECT b_c_id FROM BIAO WHERE c_id=b_c_id);

- 第九关

  购买了货币型基金的客户信息

  **子查询和any的使用**

  ```
  -- 9) 查询购买了货币型(f_type='货币型')基金的用户的名称、电话号、邮箱。
  SELECT c_name,c_phone,c_mail FROM client WHERE c_id=ANY(SELECT pro_c_id FROM property WHERE pro_pif_id=ANY(SELECT f_id FROM fund WHERE f_type='货币型')AND pro_type=3);

- 第十关

  投资总收益前三名的用户

  **LIMIT的使用**

  ```
  -- 10) 查询当前总的可用资产收益(被冻结的资产除外)前三名的客户的名称、身份证号及其总收益，按收益降序输出，总收益命名为total_income。不考虑并列排名情形。
  WITH SHOURU AS(SELECT pro_c_id,SUM(pro_income)AS total_income FROM property GROUP BY pro_c_id,pro_status HAVING pro_status='可用')
  SELECT c_name,c_id_card,total_income FROM client,SHOURU WHERE c_id=pro_c_id ORDER BY total_income DESC LIMIT 3;

- 第11关

  黄姓客户持卡数量

  **like的使用和left outer join的使用**

  ```
  -- 11) 给出黄姓用户的编号、名称、办理的银行卡的数量(没有办卡的卡数量计为0),持卡数量命名为number_of_cards,
  --     按办理银行卡数量降序输出,持卡数量相同的,依客户编号排序。
  select c_id,c_name, count(b_c_id)number_of_cards
  from client left outer join bank_card on (b_c_id=c_id)
  group by c_id
  having c_name LIKE '黄%'
  order by c_id,number_of_cards DESC;

- 第12关

  客户理财、保险与基金投资总额

  **聚合函数sum的使用**

  ```
   -- 12) 综合客户表(client)、资产表(property)、理财产品表(finances_product)、保险表(insurance)和
   --     基金表(fund)，列出客户的名称、身份证号以及投资总金额（即投资本金，
   --     每笔投资金额=商品数量*该产品每份金额)，注意投资金额按类型需要查询不同的表，
   --     投资总金额是客户购买的各类资产(理财,保险,基金)投资金额的总和，总金额命名为total_amount。
   --     查询结果按总金额降序排序。
  WITH ZICHAN AS
  (SELECT pro_c_id,sum(pro_quantity*pro_amount) total_amount 
  FROM(SELECT pro_id,pro_c_id,pro_quantity,p_amount AS pro_amount FROM property,finances_product WHERE p_id=pro_pif_id AND pro_type=1
  UNION 
  SELECT pro_id,pro_c_id,pro_quantity,i_amount AS pro_amount FROM property,insurance WHERE i_id=pro_pif_id AND pro_type=2
  UNION
  SELECT pro_id,pro_c_id,pro_quantity,f_amount AS pro_amount FROM property,fund WHERE f_id=pro_pif_id AND pro_type=3)//生成一个用户的资产表，不区分资产类型，只包含资产的数量和金额
  GROUP BY pro_c_id)//该部分为with部分的子表 ZICHAN ,生成一个表，只有用户和持有资产总额
  SELECT c_name,c_id_card,total_amount FROM client INNER JOIN ZICHAN ON c_id=pro_c_id 
  UNION
  SELECT c_name,c_id_card,0 total_amount FROM client WHERE NOT EXISTS (SELECT pro_c_id FROM ZICHAN WHERE c_id=pro_c_id)//union没有资产的人
  ORDER BY total_amount DESC;

- 第13关

  客户总资产

  ```
  -- 13) 综合客户表(client)、资产表(property)、理财产品表(finances_product)、
  --     保险表(insurance)、基金表(fund)和投资资产表(property)，
  --     列出所有客户的编号、名称和总资产，总资产命名为total_property。
  --     总资产为储蓄卡余额，投资总额，投资总收益的和，再扣除信用卡透支的金额
  --     (信用卡余额即为透支金额)。客户总资产包括被冻结的资产。
  WITH ZICHAN AS
  (SELECT pro_c_id,sum(pro_quantity*pro_amount+pro_income) total_amount 
  FROM(SELECT pro_id,pro_c_id,pro_quantity,p_amount AS pro_amount,pro_income FROM property,finances_product WHERE p_id=pro_pif_id AND pro_type=1
  UNION 
  SELECT pro_id,pro_c_id,pro_quantity,i_amount AS pro_amount,pro_income FROM property,insurance WHERE i_id=pro_pif_id AND pro_type=2
  UNION
  SELECT pro_id,pro_c_id,pro_quantity,f_amount AS pro_amount,pro_income FROM property,fund WHERE f_id=pro_pif_id AND pro_type=3)
  GROUP BY pro_c_id),//子表ZICHAN
  TOUZI AS
  (SELECT c_id,c_name,total_amount FROM client INNER JOIN ZICHAN ON c_id=pro_c_id 
  UNION
  SELECT c_id,c_name,0 total_amount FROM client WHERE NOT EXISTS (SELECT pro_c_id FROM ZICHAN WHERE c_id=pro_c_id)),//子表TOUZI
  YINHANG AS
  (SELECT b_c_id,SUM(card_balance) total_balance FROM(SELECT b_number,b_c_id,b_balance card_balance FROM bank_card WHERE b_type='储蓄卡'
  UNION
  SELECT b_number,b_c_id,b_balance*(-1) card_balance FROM bank_card WHERE b_type='信用卡') GROUP BY b_c_id)//子表YINHANG
  SELECT c_id,c_name,total_amount+total_balance total_property FROM TOUZI,YINHANG WHERE c_id=b_c_id 
  UNION
  SELECT c_id,c_name,0 total_property FROM TOUZI WHERE NOT EXISTS (SELECT b_c_id FROM YINHANG WHERE c_id=b_c_id)//union上三个子表没有的人
  ORDER BY c_id;

- 第14关

  第N高问题

  **LIMIT n OFFSET m的用法：找到从第m个开始的n条记录 **

  ```
  -- 14) 查询每份保险金额第4高保险产品的编号和保险金额。
  --     在数字序列8000,8000,7000,7000,6000中，
  --     两个8000均为第1高，两个7000均为第2高,6000为第3高。
  SELECT i_id,i_amount FROM insurance WHERE i_amount=(SELECT i_amount FROM ( SELECT DISTINCT i_amount FROM insurance ) ORDER BY i_amount DESC LIMIT 1 OFFSET 3) ORDER BY i_id;

- 第15关

  基金收益两种方式排名

  **RANK函数和DENSE_RANK函数**

  ```
  -- 15) 查询资产表中客户编号，客户基金投资总收益,基金投资总收益的排名(从高到低排名)。
  --     总收益相同时名次亦相同(即并列名次)。总收益命名为total_revenue, 名次命名为rank。
  --     第一条SQL语句实现全局名次不连续的排名，
  --     第二条SQL语句实现全局名次连续的排名。
  -- (1) 基金总收益排名(名次不连续)
  SELECT pro_c_id,SUM(pro_income) total_revenue,RANK() OVER(ORDER BY total_revenue DESC)AS rank FROM property WHERE pro_type=3 GROUP BY pro_c_id  ORDER BY total_revenue DESC,pro_c_id;
  -- (2) 基金总收益排名(名次连续)
  SELECT pro_c_id,SUM(pro_income) total_revenue,DENSE_RANK() OVER(ORDER BY total_revenue DESC)AS rank FROM property WHERE pro_type=3 GROUP BY pro_c_id  ORDER BY total_revenue DESC,pro_c_id;

- 第16关

  持有完全相同基金组合的客户

  **选出一个用户的基金数量，用另一个表去除**

  ```
  -- 16) 查询持有相同基金组合的客户对，如编号为A的客户持有的基金，编号为B的客户也持有，反过来，编号为B的客户持有的基金，编号为A的客户也持有，则(A,B)即为持有相同基金组合的二元组，请列出这样的客户对。为避免过多的重复，如果(1,2)为满足条件的元组，则不必显示(2,1)，即只显示编号小者在前的那一对，这一组客户编号分别命名为c_id1,c_id2。
  WITH T1 AS(SELECT c_id c_id1 FROM client),T2 AS(SELECT c_id c_id2 FROM client)
  SELECT c_id1,c_id2 FROM T1,T2 WHERE c_id1<c_id2 
  AND EXISTS(SELECT pro_c_id FROM property WHERE pro_c_id=c_id1 AND pro_type=3) 
  AND EXISTS(SELECT pro_c_id FROM property WHERE pro_c_id=c_id2 AND pro_type=3) //筛选买了基金的人
  AND NOT EXISTS(
  (SELECT FUND1 FROM (SELECT  pro_pif_id FUND1 FROM property WHERE pro_type=3 AND pro_c_id=c_id1)AS T3(FUND1) WHERE NOT EXISTS (SELECT pro_pif_id  FROM property WHERE pro_type=3 AND pro_c_id=c_id2 AND pro_pif_id=T3.FUND1))
  )//t1的用户基金t2中用户都包含
  AND NOT EXISTS(
  (SELECT FUND2 FROM (SELECT  pro_pif_id FUND2 FROM property WHERE pro_type=3 AND pro_c_id=c_id2)AS T4(FUND2) WHERE NOT EXISTS (SELECT pro_pif_id  FROM property WHERE pro_type=3 AND pro_c_id=c_id1 AND pro_pif_id=T4.FUND2)));//t2的用户基金t1中用户都包含，取交集就是相等

- 第17关

  购买基金的高峰期

  **TO_CHAR是将日期转换成字符串，再用LIKE进行匹配比较；extract是将日期转换为周几的函数，0表示周日，123456表示周一二三四五六**

  **三种情况：①该天的前两天；②该天的前后各一天；③该天的后两天。要么是周六日要么超过1000000**

  ```
  -- 17 查询2022年2月购买基金的高峰期。至少连续三个交易日，所有投资者购买基金的总金额超过100万(含)，则称这段连续交易日为投资者购买基金的高峰期。只有交易日才能购买基金,但不能保证每个交易日都有投资者购买基金。2022年春节假期之后的第1个交易日为2月7日,周六和周日是非交易日，其余均为交易日。请列出高峰时段的日期和当日基金的总购买金额，按日期顺序排序。总购买金额命名为total_amount。
  
  WITH T1 AS
  (SELECT pro_purchase_time,SUM(pro_quantity*f_amount) amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING amount>1000000 AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time),
  T2 AS
  (SELECT pro_purchase_time p_time,SUM(pro_quantity*f_amount) amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING amount>1000000 AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time)
  SELECT pro_purchase_time,amount FROM(
  (SELECT pro_purchase_time,amount FROM T1 WHERE 
  ((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-2) OR (extract(dow from pro_purchase_time-2)=6) OR (extract(dow from pro_purchase_time-2)=0))
  AND
  (EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-1) OR (extract(dow from pro_purchase_time-1)=6) OR (extract(dow from pro_purchase_time-1)=0)))
  )
  UNION
  (SELECT pro_purchase_time,amount FROM T1 WHERE
  ((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+1) OR (extract(dow from pro_purchase_time+1)=6) OR (extract(dow from pro_purchase_time+1)=0))
  AND
  (EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-1) OR (extract(dow from pro_purchase_time-1)=6) OR (extract(dow from pro_purchase_time-1)=0)))
  )
  UNION
  (SELECT pro_purchase_time,amount FROM T1 WHERE
  ((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+2) OR (extract(dow from pro_purchase_time+2)=6) OR (extract(dow from pro_purchase_time+2)=0))
  AND
  (EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+1) OR (extract(dow from pro_purchase_time+1)=6) OR (extract(dow from pro_purchase_time+1)=0)))
  )
  ) ORDER BY pro_purchase_time;

- 第18关

  **至少有一张信用卡**金额超过5000元的客户信用卡总金

  **即最大金额超过即可**

  ```
   -- 18) 查询至少有一张信用卡余额超过5000元的客户编号，以及该客户持有的信用卡总余额，总余额命名为credit_card_amount。
  SELECT b_c_id,SUM(b_balance) credit_card_amount FROM bank_card WHERE b_type='信用卡' GROUP BY b_c_id HAVING MAX(b_balance)>5000 ORDER BY b_c_id;

- 第19关

  以日历表格式显示每日基金购买总金额

  分组统计； 日期函数的应用； if或case函数的用法； 有规律的行列转换。

  - date_part('week',d1) - 日期d1在当年的周次。week('2022-2-7') = 6;
  - extract(DOW FROM cast(d1 as TIMESTAMP) - 返回d1在本周的次序(0 = Sunday, 1 = Monday, …, 6 = Saturday)
  - case when expr1 then expr2 else expr3 end - 若expr1为TRUE，返回expr2，否则返回expr3.

  ```
  -- 19) 以日历表格式列出2022年2月每周每日基金购买总金额，输出格式如下：
  -- week_of_trading Monday Tuesday Wednesday Thursday Friday
  --               1
  --               2    
  --               3
  --               4
  --   请用一条SQL语句实现该查询：
  WITH GOUMAI AS
  (SELECT pro_purchase_time,SUM(pro_quantity*f_amount) total_amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time),
  //把购买时间和金额筛选出来
  T1 AS
  (SELECT DATE_PART('WEEK',pro_purchase_time)-5 week_of_trading,
  (CASE WHEN extract(dow from pro_purchase_time)=1 THEN total_amount END) AS Monday,
  (CASE WHEN extract(dow from pro_purchase_time)=2 THEN total_amount END) AS Tuesday,
  (CASE WHEN extract(dow from pro_purchase_time)=3 THEN total_amount END) AS Wendnesday,
  (CASE WHEN extract(dow from pro_purchase_time)=4 THEN total_amount END) AS Thursday,
  (CASE WHEN extract(dow from pro_purchase_time)=5 THEN total_amount END) AS Friday FROM  GOUMAI),
  //把日期集中在T1这个表中
  MONDAY AS(
      SELECT week_of_trading,Monday FROM T1 WHERE Monday IS NOT NULL
  ),
  //找星期一的金额
  TUESDAY AS(
      SELECT week_of_trading,Tuesday FROM T1 WHERE Tuesday IS NOT NULL
  ),
  //找星期二的金额
  WEDNESDAY AS(
      SELECT week_of_trading,Wendnesday FROM T1 WHERE Wendnesday IS NOT NULL
  ),
  //找星期三的金额
  THURSDAY AS(
      SELECT week_of_trading,Thursday FROM T1 WHERE Thursday IS NOT NULL
  ),
  //找星期四的金额
  FRIDAY AS(
      SELECT week_of_trading,Friday FROM T1 WHERE Friday IS NOT NULL
  )
  //找星期五的金额
  SELECT MONDAY.week_of_trading,Monday,Tuesday,Wendnesday,Thursday,Friday FROM MONDAY LEFT OUTER JOIN TUESDAY ON MONDAY.week_of_trading=TUESDAY.week_of_trading LEFT OUTER JOIN WEDNESDAY ON MONDAY.week_of_trading=WEDNESDAY.week_of_trading LEFT OUTER JOIN THURSDAY ON MONDAY.week_of_trading=THURSDAY.week_of_trading LEFT OUTER JOIN FRIDAY ON MONDAY.week_of_trading=FRIDAY.week_of_trading;
  //周1、2、3、4、5合起来，这个样例中用left outer join即可，但普遍情况应该left outer join和right outer join筛选出来两个表然后union一下
  
  /*  end  of  your code  */

- 第20关

  查询销售总额前三的理财产品

   查询**2010年和2011年这两年每年销售总额前3名**（如果有并列排名，则后续排名号跳过之前的并列排名个数，例如1、1、3）的统计年份（pyear）、销售总额排名值(rk)、理财产品编号(p_id)、销售总额(sumamount)。   注意结果输出要求：(1)按照年份升序排列，同一年份按照销售总额的排名值升序排列，如遇到并列排名则按照理财产品编号升序排列;(2)属性显示：统计年份（pyear）、销售总额排名值(rk)、理财产品编号(p_id)、销售总额(sumamount)（3）结果显示顺序：先按照统计年份（pyear）升序排,同一年份按照销售总额排名值（rk）升序排,同一排名值的按照理财产品编号（p_id ）升序排。

  **使用的语法：**

  **嵌套查询； rank() over(partition by ...order by)的使用。**

  ```
  -- 20) 查询销售总额前三的理财产品
  --   请用一条SQL语句实现该查询：
  (SELECT pyear,rank()over(partition by pyear order by sumamount DESC) rk,p_id,sumamount FROM
  (
  SELECT p_id, 2010 pyear,pro_quantity*p_amount sumamount FROM property,finances_product WHERE  pro_type=1 AND p_id=pro_pif_id AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2010%'
  )//从property和finances_product两个表中筛选出来理财产品2010年购买的编号、金额、时间
  ORDER BY pyear,sumamount DESC LIMIT 3)//排序并选出来前三个
  
  UNION//将2010年和2011年俩表合并得到最后的表
  
  (SELECT pyear,rank()over(partition by pyear order by sumamount DESC) rk,p_id,sumamount FROM
  (
  SELECT p_id,2011 pyear,pro_quantity*p_amount sumamount FROM property,finances_product WHERE  pro_type=1 AND p_id=pro_pif_id AND  TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2011%'
  )//从property和finances_product两个表中筛选出来理财产品2011年购买的编号、金额、时间
  ORDER BY pyear,sumamount DESC LIMIT 3)//排序并选出来前三个
  ;
  --/*  end  of  your code  */
  ```

- 第21关

  投资积极且偏好理财类产品的客户

  题目详情：购买了**3种（同一编号的理财产品记为一种）以上理财产品**的客户被认为投资积极的客户，若该客户**持有基金产品种类数（同一基金编号记为相同的基金产品种类）小于其持有的理财产品种类数**，则认为该客户为投资积极且偏好理财产品的客户。查询所有此类客户的编号(pro_c_id)。 注意结果输出要求：按照客户编号的**升序排列**，且**去除重复**结果。

  ```
  -- 21) 投资积极且偏好理财类产品的客户
  --   请用一条SQL语句实现该查询：
  WITH T1 AS
  (SELECT pro_c_id,count(*) financenum FROM property WHERE pro_type=1 GROUP BY pro_c_id HAVING count(*)>3),//找到理财产品拥有三个以上的id并记录数量
  T2 AS
  (SELECT pro_c_id,count(*) fundnum FROM property WHERE pro_type=3 GROUP BY pro_c_id)//找到基金拥有的数量
  SELECT T1.pro_c_id FROM T1,T2 WHERE financenum>fundnum AND T1.pro_c_id=T2.pro_c_id;//删选出来理财产品数量＞基金数量的id
  --/*  end  of  your code  */
  ```

- 第22关

  查询购买了所有畅销理财产品的客户

  若定义**持有人数超过2的理财产品**称为畅销理财产品。查询**购买了所有畅销理财产品的**客户编号(pro_c_id)。 注意结果输出要求：按照客户编号的升序排列，且去除重复结果。

  ```
  -- 22) 查询购买了所有畅销理财产品的客户
  --   请用一条SQL语句实现该查询：
  WITH CX AS(
      SELECT DISTINCT pro_pif_id FROM property  WHERE pro_type=1 GROUP BY pro_pif_id HAVING COUNT(*)>2),//CX保存了畅销产品的id
  CXCLINET AS(
  SELECT DISTINCT pro_c_id FROM property WHERE pro_type=1)//CXCLIENT保存了购买了理财产品的id
  SELECT pro_c_id FROM CXCLINET WHERE NOT EXISTS(
      SELECT pro_pif_id FROM CX WHERE NOT EXISTS(
          SELECT pro_pif_id FROM property WHERE pro_type=1 AND property.pro_c_id=CXCLINET.pro_c_id AND property.pro_pif_id=CX.pro_pif_id
      )//查找该pro_c_id下没有购买的畅销理财产品的表
  )//该表如果不存在那么就是购买了所有的畅销理财产品
  ;
  --/*  end  of  your code  */
  ```

- 第23关

  查找相似的理财产品

  在某些推荐方法中，需要查找某款理财产品相似的其他理财产品，不妨设其定义为：对于某款理财产品A，可找到**持有A数量最多的“3”个**（包括所有持有相同数量的客户，因此如有3个并列第一、1个第二、一个第三，则排列结果是1,1,1,2,3）客户，然后对于**这“3”个客户持有的所有理财产品**（不包含产品A自身），每款产品被全体客户**持有总人数被认为是和产品A的相似度，**若有相似度相同的理财产品，则为了便于后续处理的确定性，则这些相似度相同的理财产品间按照产品编号的升序排列。按照和产品A的相似度，**最多的“3”款（同上理，前3名允许并列的情况，例如排列结果是1,2,2,2,3）理财产品，就是产品A的相似的理财产品。** 

  请查找产品14的相似理财产品编号（不包含14自身）（pro_pif_id）、该编号的理财产品的客购买客户总人数（cc）以及该理财产品对于14  号理财产品的相似度排名值（prank）。 注意结果输出要求：**按照相似度值降序排列**，相同相似度的理财产品之间则按照产品编号的升序排列。

  ```
  -- 23) 查找相似的理财产品
  --   请用一条SQL语句实现该查询：
  
  WITH CLIENT14 AS(
       SELECT pro_c_id,DENSE_RANK() OVER(PARTITION BY pro_pif_id ORDER BY pro_quantity DESC) AS rk FROM property WHERE pro_type=1 AND pro_pif_id=14 
  ),//购买了14号理财产品的客户名单
  T1 AS(
       SELECT DISTINCT pro_pif_id FROM property WHERE pro_type=1 AND EXISTS(SELECT pro_c_id FROM CLIENT14 WHERE pro_c_id=property.pro_c_id AND rk<=3)
  )//购买了14号理财产品的客户所购买的理财产品单子
  SELECT DISTINCT pro_pif_id,COUNT(*) cc,DENSE_RANK()OVER(ORDER BY cc DESC) AS prank FROM property WHERE pro_type=1 AND pro_pif_id!=14 AND EXISTS(
       SELECT pro_pif_id FROM T1 WHERE pro_pif_id=property.pro_pif_id
  )
  GROUP BY pro_pif_id;//对存在与T1表的理财产品排序
  --/*  end  of  your code  */
  ```

- 第24关

  查询任意两个客户的相同理财产品数

  查询**任意两个客户之间持有的相同理财产品种数**，并且结果仅保留相同理财产品数至少2种的用户对。  注意结果输出要求：第一列和第二列输出客户编号(pro_c_id,pro_c_id)，第三列输出他们持有的相同理财产品数(total_count)，按照第一列的客户编号的升序排列。

  ```
  -- 24) 查询任意两个客户的相同理财产品数
  --   请用一条SQL语句实现该查询：
  WITH T1 AS(
        SELECT pro_c_id,pro_pif_id FROM property WHERE pro_type=1
  ),//购买了理财产品的客户与理财产品表
  T2 AS(
        SELECT property.pro_c_id id1,T1.pro_c_id id2,property.pro_pif_id FROM property,T1 WHERE pro_type=1 AND property.pro_pif_id=T1.pro_pif_id AND property.pro_c_id!=T1.pro_c_id
  )//购买了相同的理财产品的用户和所购买的相同的理财产品表
  SELECT id1 pro_c_id,id2 pro_c_id,COUNT(*) total_count FROM T2 GROUP BY id1,id2 HAVING COUNT(*)>=2 ORDER BY id1;
  ;//查找购买了>=2的相同产品的客户
  --/*  end  of  your code  */
  ```

- 第25关

  查询相似的理财客户
  
   在某些推荐方法中，需要**查找某位客户在理财行为上相似的其他客户**，不妨设其定义为：对于A客户，其购买的理财产品集合为{P}，另所有买过{P}中至少一款产品的其他客户集合为{B}，则{B}中每位用户购买的{P}中产品的数量为他与A客户的相似度值。将{B}中客户按照相似度值降序排列，得到A客户的相同相似度值则按照客户编号升序排列，这样取前两位客户即为A客户的相似理财客户列表。   
  
  任务：查询每位客户(列名：pac)的相似度排名值小于3的相似客户(列名：pbc)列表，以及该每位客户和他的每位相似客户的共同持有的理财产品数(列名：common)、相似度排名值(列名：crank)。 
  
   注意结果输出要求：要求结果先按照左边客户编号(pac)升序排列，同一个客户的相似客户则按照客户相似度排名值（crank）顺序排列。
  
  ```
  -- 25) 查找相似的理财客户
  --   请用一条SQL语句实现该查询：
  WITH T1 AS(
        SELECT pro_c_id,pro_pif_id FROM property WHERE pro_type=1
  ),--购买了理财产品的客户与理财产品表
  T2 AS(
        SELECT property.pro_c_id pac,T1.pro_c_id pbc,property.pro_pif_id FROM property,T1 WHERE pro_type=1 AND property.pro_pif_id=T1.pro_pif_id AND property.pro_c_id!=T1.pro_c_id
  ),--购买了相同的理财产品的用户和所购买的相同的理财产品表
  T3 AS(
         SELECT pac,pbc,COUNT(*) common,RANK()OVER(PARTITION BY pac ORDER BY common DESC,pbc) AS crank FROM T2 GROUP BY pac,pbc
  )--购买了相同理财产品的用户以及购买的相同产品数和排名
  SELECT pac,pbc,common,crank FROM T3 WHERE crank<=2 ORDER BY pac,crank;
  ;--找到相似度前两名的客户对
  --/*  end  of  your code  */
  ```
  
  

## 数据的插入、修改与删除 

- 第1关

  向客户表插入以下3条数据

  ```
  -- 用insert语句向客户表(client)插入任务要求的3条数据:
  INSERT INTO  client (c_id,c_name,c_mail,c_id_card,c_phone,c_password) VALUES
  (1,'林惠雯','960323053@qq.com','411014196712130323','15609032348','Mop5UPkl'),
  (2,'吴婉瑜','1613230826@gmail.com','420152196802131323','17605132307','QUTPhxgVNlXtMxN'),
  (3,'蔡贞仪','252323341@foxmail.com','160347199005222323','17763232321','Bwe3gyhEErJ7');
  /* end of you code */
  ```

- 第2关

  向客户表client插入一条数据不全的记录。

  ```
  -- 已知33号客户部分信息如下:
  -- c_id(编号):33
  -- c_name(名称):蔡依婷
  -- c_phone(电话):18820762130
  -- c_id_card(身份证号):350972199204227621
  -- c_password(密码):MKwEuc1sc6
  
  -- 请用一条SQL语句将这名客户的信息插入到客户表(client)：
  
  
  INSERT INTO  client (c_id,c_name,c_id_card,c_phone,c_password) VALUES
  (33,'蔡依婷','350972199204227621','18820762130','MKwEuc1sc6');
  /* the end of your code */ 
  ```

- 第3关

  向客户表client批量插入数据

  已知表new_client保存了一批新客户信息，该表与client表结构完全相同。请用一条SQL语句将new_client表的全部客户信息插入到客户表(client)。

  ```
  -- 已知表new_client保存了一批新客户信息，该表与client表结构完全相同。请用一条SQL语句将new_client表的全部客户信息插入到客户表(client):
  -- c_id | c_name |             c_mail             |     c_id_card      |   c_phone
  
  INSERT INTO  client 
  SELECT * FROM new_client;
  
  /* the end of your code */
  ```

- 第4关

  请用一条SQL语句删除client表中没有银行卡的客户信息。

  ```
  -- 请用一条SQL语句删除client表中没有银行卡的客户信息：
  DELETE FROM client WHERE NOT EXISTS(
      SELECT b_number FROM bank_card WHERE b_c_id=c_id
  );
  /* the end of your code */ 
  ```

- 第5关

  请用一条update语句将手机号码为“13686431238”这位客户的投资资产(理财、保险与基金)的状态置为“冻结”。

  ```
  -- 请用一条update语句将手机号码为“13686431238”的这位客户的投资资产(理财、保险与基金)的状态置为“冻结”。：
  UPDATE property SET pro_status='冻结' WHERE EXISTS(
      SELECT c_id FROM client WHERE c_phone='13686431238'AND c_id=property.pro_c_id
  );
  /* the end of your code */
  ```

- 第6关

  请用一条update语句，根据client表中提供的身份证号(c_id_card)，填写property表中对应的身份证号信息(pro_id_card)。

  ```
  -- 在金融应用场景数据库中，已在表property(资产表)中添加了客户身份证列，列名为pro_id_card，类型为char(18)，该列目前全部留空(null)。
  -- 请用一条update语句，根据client表中提供的身份证号(c_id_card)，填写property表中对应的身份证号信息(pro_id_card)。
  UPDATE property SET pro_id_card=(
      SELECT c_id_card FROM client WHERE c_id=pro_c_id
  );
  /* the end of your code */
  ```

## 视图

- **VIEW**

  **View（视图）是一张假表，只不过是通过相关的名称存储在数据库中的一个 PostgreSQL 语句。**

  **View（视图）实际上是一个以预定义的 PostgreSQL 查询形式存在的表的组合。**

  **View（视图）可以包含一个表的所有行或从一个或多个表选定行。**

  **View（视图）可以从一个或多个表创建，这取决于要创建视图的 PostgreSQL 查询。**

  **View（视图）是一种虚拟表，允许用户实现以下几点：**

  - **用户或用户组认为更自然或直观查找结构数据的方式。**
  - **限制数据访问，用户只能看到有限的数据，而不是完整的表。**
  - **汇总各种表中的数据，用于生成报告。**

  **PostgreSQL 视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。但是可以在视图上创建一个触发器，当尝试 DELETE、INSERT 或 UPDATE 视图时触发，需要做的动作在触发器内容中定义。**

- 第1关

  填写1条SQL语句，完成以下任务： 创建包含所有保险资产记录的详细信息的视图v_insurance_detail，包括购买客户的名称、客户的身份证号、保险名称、保障项目、商品状态、商品数量、保险金额、保险年限、商品收益和购买时间。

  ```
  -- 创建包含所有保险资产记录的详细信息的视图v_insurance_detail，包括购买客户的名称、客户的身份证号、保险名称、保障项目、商品状态、商品数量、保险金额、保险年限、商品收益和购买时间。
  -- 请用1条SQL语句完成上述任务：
  CREATE VIEW v_insurance_detail AS
  SELECT c_name,c_id_card,i_name,i_project,pro_status,pro_quantity,i_amount,i_year,pro_income,pro_purchase_time FROM client,property,insurance WHERE pro_type=2 AND pro_c_id=c_id AND pro_pif_id=i_id;
  /*   end  of your code  */
  ```

- 第2关

  基于上一关创建的视图v_insurance_detail进行分组统计查询，列出每位客户的姓名，身份证号，保险投资总额(insurance_total_amount)和保险投资总收益(insurance_total_revenue),结果依保险投资总额降序排列。

  ```
   -- 基于上一关创建的视图v_insurance_detail进行分组统计查询，列出每位客户的姓名，身份证号，保险投资总额(insurance_total_amount)和保险投资总收益(insurance_total_revenue),结果依保险投资总额降序排列。
  --  请用一条SQL语句实现该查询：
  SELECT c_name,c_id_card,SUM(pro_quantity*i_amount) insurance_total_amount,SUM(pro_income) insurance_total_revenue FROM v_insurance_detail GROUP BY c_name,c_id_card ORDER BY insurance_total_amount DESC;
  /*  end  of  your code  */
  ```

## 存储过程与事务

- 第1关

  任务：创建一个存储过程，向表fibonacci插入斐波拉契数列的前n项。

  知识点：

  - 变量定义与赋值

    用declare语句定义变量，并赋予默认值或初始值，未赋默认值 则初始值为null:

     `DECLARE var_name [, var_name] ... type [DEFAULT value]` 

    在OpenGauss中，变量赋值语句如下：

     `variable := expr [, variable = expr]`

    还可以通过select语句给变量赋值：

     `select col into var_name from table; #将table表中的col列值赋给变量`

  - 复合语句

    1.复合语句BEGIN...END

    ```
    BEGIN[statement_list]END 
    ```

    2.if语句

    ```
    IF search_condition THEN  statement_list[ELSEIF search_condition THEN statement_list] ...[ELSE statement_list]END IF 
    ```

    3.while语句

    ```
    WHILE search_condition LOOP   statement_listEND LOOP
    ```

  - 存储过程定义

    **存储过程**（`Stored Procedure`）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。

    存储过程是为了完成特定功能的 `SQL` 语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行。

    存储过程思想上很简单，就是数据库 `SQL` 语言层面的代码**封装与重用**。

    简单的说存储过程就是具有名字的一段代码，用来完成一个特定的功能。

  - 存储过程的创建和查询

    创建存储过程：`create procedure 存储过程名(参数) `

    - 下面我们来创建第一个存储过程

    每个存储的程序都包含一个由 `SQL` 语句组成的主体。此语句可能是由以分号（`;`）字符分隔的多个语句组成的复合语句。例如：

    ```
    CREATE PROCEDURE proc1()as
    BEGIN
    insert into test values(1);
    END;
    \
    ```

    在命令行客户端中，如果有一行命令以分号结束，那么回车后，`OpenGauss` 将会执行该命令，但在创建存储过程中我们并不希望 `OpenGauss` 这么做。于是使用（create procedure proc_name as） 开头，以符号（\）结尾。中间的（;）就会忽略。

    - 执行存储过程：`call 存储过程名`
    - 创建带有参数的存储过程 存储过程的参数有三种：
      - `IN`：输入参数，也是默认模式，表示该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回；
      - `OUT`：输出参数，该值可在存储过程内部被改变，并可返回；
      - `IN OUT`：输入输出参数，调用时指定，并且可被改变和返回。

  ```
  -- 创建存储过程`sp_fibonacci(in m int)`，向表fibonacci插入斐波拉契数列的前m项，及其对应的斐波拉契数。fibonacci表初始值为一张空表。请保证你的存储过程可以多次运行而不出错。
  
  create procedure sp_fibonacci(in m int)
  as
  declare i int default 0;--用来计数几个值
  declare f0 bigint default 0;--要插入的当前值
  declare f1 bigint default 1;--要插入的下一个值
  declare f2 bigint default 1; --要插入的下下一个值
  begin
  -- ######## 请补充代码完成存储过程体 ########
  
  while i<m loop
      insert into fibonacci values(i,f0);
      i:=i+1;
      f0:=f1;
      f1:=f2;
      f2:=f0+f1;
  end loop;
  
  end;
  /
  ```

- 第2关

  **知识点：**

  ##### 游标的特点

  SQL操作都是面向集合的，即操作的对象以及运算的结果均为集合，但有时候，我们需要一行一行地处理数据，这就需要用到游标(CURSOR)，它相当于一个存储于内存的带有指针的表，每次可以存取指针指向的一行数据，并将指针向前推进一行。游标的数据通常是一条查询语句的结果。对游标的操作一般要用循环语句，遍历游标的每一行数据，并将该行数据读至变量，再根据变量的值进行所需要的其它操作。

  游标有以下持点：

  - 不可滚动。即只能从前往后遍历游标数据(即从第1行到最后一行)，不能反向遍历，不能跳跃遍历，不能直接访问中间的某一行。
  - 只读。游标里的数据只能读取，不能修改。

  ##### 游标的定义与使用

  创建并使用OpenGauss游标，至少会用到声明游标, OPEN, FETCH, 和CLOSE语句。

  **1.声明游标语句** 用DECLARE语句变量以及特情处理程序，用CURSOR语句定义游标。在一个BEGIN...END语句块内，DECLARE定义的顺序要求如下：

  1. 变量
  2. 游标
  3. 特情处理

  即变量定义在游标之前，特情处理程序定义在游标之后。 变量用来存储从游标读取的数据，根据编程逻辑的需，可能还要定义其它变量；游标用来存储SELECT语句读取的数据集；当某些特定情形出现时，会自动触发对应的特情处理程序。在游标的使用中，你至少需要定义当遍历至游标数据结束(抛出NOT FOUND异常)时该怎么办(当然是结束循环)。

  定义变量： `DECLARE var_name [, var_name] ... type [DEFAULT value]`

  定义游标： `CURSOR cursor_name  FOR select_statement` 任何合法的select语句(不能带INTO短语)，都可以定义成游标。此后可用FETCH语句读取这个select语句查询到的数据集中的一行数据。

  注意游标必须定义在变量之后，特情处理程序之前。 一个存储过程可义定义多个游标，但不能同名。

  特情处理：

  游标应用中需要注意FETCH语句结束的情况： `LOOP`  `FETCH C1 INTO TEMP;`  `EXIT WHEN C1%NOTFOUND;` `END LOOP;` 其含义是将C1游标的值付给变量TEMP，当游标C1有值时C1%NOTFOUND置0，取不到值时C1%NOTFOUND置1，语句EXIT WHEN C1%NOTFOUND表示当C1%NOTFOUND为1时退出循环。

  当一个存储过程中存在多个游标时，对任何一个游标的读取(FETCH)都可能会触发特情处理。比如一个游标的数据被遍历完毕，再试图FETCH下一行时，会触发NOT FOUND HANDLER, 并进而改变某个变量的值，但另一个游标中可能还有未处理完的数据。编程者应当自己想办法区分是哪个游标的数据处理完毕。 

  **2. OPEN语句** `OPEN cursor_name` 该语句打开之前定义的游标，并初始化指向数据行的指针(接下来的第一条FETCH语句将试图读取游标的第1行数据)。

  **3.FETCH语句** `FETCH [[NEXT] FROM] cursor_name INTO var_name [, var_name] ...` FETCH语句读取游标的一行数据到变量列表,并推进游标的指针.关键词NEXT, FROM都可省略(或仅省略NEXT)。注意INTO后的变量列表应当与游标定义中的SELECT列表一一对应(变量个数与SELECT列表个数完全相同，数据类型完全一致，每个变量的取值按SELECT列表顺序一一对应)。

  FETCH一个未打开的游标会出错。

  **4. CLOSE语句** `CLOSE cursor_name` Close语句关闭先前打开的游标，试图关闭一个未曾打开(OPEN)的游标会出错。

  没有CLOSE的游标，在其定义的BEGIN...END语句块结束时，将自动CLOSE。

  任务：

  ```
  -- 编写一存储过程，自动安排某个连续期间的大夜班的值班表:
  create procedure sp_night_shift_arrange(in start_date date, in end_date date)
  AS
  CURSOR doctor FOR
  select e_name from employee where e_type=1 or e_type=2 order by e_id;
  CURSOR nurse FOR
  select e_name from employee where e_type=3 order by e_id;
  declare cur_date date;
  declare doctor_name char(30);
  declare nurse_name1 char(30);
  declare nurse_name2 char(30);
  declare doctor_type int;
  declare flag int default 0;
  declare zhou int;
  declare zhuren char(30);
  
  begin
      open doctor;
      open nurse;
      cur_date:=start_date;
      select e_name into zhuren from employee where e_type=1;
      while cur_date<=end_date loop
          zhou:=extract(dow from cur_date);--这一天是周几
          if zhou=0 or zhou=6 then--周六和周日判断当前是否是主任
              fetch doctor into doctor_name;--先找到这个人
              if doctor%notfound then --doctor已经遍历完了，就重头开始
                  close doctor;
                  open doctor;
                  fetch doctor into doctor_name;
              end if;
              if doctor_name=zhuren then --如果是主任
                  flag:=1;
                  fetch doctor into doctor_name;--再找一个医生
                  if doctor%notfound then --doctor已经遍历完了，就重头开始
                      close doctor;
                      open doctor;
                      fetch doctor into doctor_name;
                  end if;
              end if;
          elseif zhou=1 then--如果是周一
              if flag=1 then 
                  doctor_name=zhuren;--之前主任轮空，轮到主任
                  flag=0;
              else 
                  fetch doctor into doctor_name;--之前主任没有轮空
                  if doctor%notfound then --doctor已经遍历完了，就重头开始
                      close doctor;
                      open doctor;
                      fetch doctor into doctor_name;
                  end if;
              end if;
          else
              fetch doctor into doctor_name;--普通情况找一个医生
              if doctor%notfound then --doctor已经遍历完了，就重头开始
                  close doctor;
                  open doctor;
                  fetch doctor into doctor_name;
              end if;
          end if;
          fetch nurse into nurse_name1;
          if nurse%notfound then--找护士1
              close nurse;
              open nurse;
              fetch nurse into nurse_name1;
          end if;
          fetch nurse into nurse_name2;
          if nurse%notfound then
              close nurse;
              open nurse;
              fetch nurse into nurse_name2;
          end if;
          insert into night_shift_schedule values(cur_date,doctor_name,nurse_name1,nurse_name2);
          cur_date:=cur_date::date+interval'1 D';
      end loop;
      close doctor;
      close nurse;
  end;
  /*  end  of  your code  */ 
  
  
  值得注意的是下面的这种写法是不对的，游标到了结尾再fetch一下才能notfound
          if nurse%notfound then--找护士
              close nurse;
              open nurse;
          else
              fetch nurse into nurse_name1;
          end if;
          if nurse%notfound then
              close nurse;
              open nurse;
          else
              fetch nurse into nurse_name2;
          end if;
          insert into employee values(cur_date,zhou,doctor_name,nurse_name1,nurse_name2);
          cur_date:=cur_date::date+interval'1 D';
  
  
  ```

- 第3关

  知识点：

  ##### **事务的定义和应用**

  开启事务： • 在OpenGauss中，存储过程本身就处于一个事务中，开始调用最外围存储过程时会自动开启一个事务，在调用结束时自动提交或者发生异常时回滚。除了系统自动的事务控制外，也可以使用COMMIT/ROLLBACK来控制存储过程中的事务。在存储过程中调用COMMIT/ROLLBACK命令，将提交/回滚当前事务并自动开启一个新的事，后续的所有操作都会在此新事务中运行。所以在存储过程中不要使用start transaction开启事务。 事务提交： • COMMIT  事务回滚： • ROLLBACK

  任务：

  - 仅当转款人是转出卡的持有人时，才可转出；
  - 仅当收款人是收款卡的持有人时，才可转入；
  - 储蓄卡之间可以相互转账；
  - 允许储蓄卡向信用卡转账，称为信用卡还款(允许替它人还款)，还款可以超过信用卡余额，此时，信用卡余额为负数；
  - 信用卡不能向储蓄卡转账；
  - 转账金额不能超过储蓄卡余额；

  ```
  -- 在金融应用场景数据库中，编程实现一个转账操作的存储过程sp_transfer_balance，实现从一个帐户向另一个帐户转账。
  -- 请补充代码完成该过程：
  create procedure sp_transfer(IN applicant_id int,      
                       IN source_card_id char(30),
  					 IN receiver_id int, 
                       IN dest_card_id char(30),
  					 IN	amount numeric(10,2),
  					 OUT return_code int)
  as 
  declare a_type char(20);
  declare r_type char(20);
  declare balance NUMERIC(10,2);
  
  begin	
  	--仅当转款人是转出卡的持有人时，才可转出；
      if not exists (select b_c_id from bank_card where b_c_id=applicant_id and b_number=source_card_id) 
      then return_code:=0;return;
      end if;
  	--仅当收款人是收款卡的持有人时，才可转入；
      if not exists (select b_c_id from bank_card where b_c_id=receiver_id AND b_number=dest_card_id) 
      then return_code:=0;return 0;
      end if;
      select b_type into a_type from bank_card where b_number=source_card_id;--付款人的卡类型
      select b_type into r_type from bank_card where b_number=dest_card_id;--收款人卡类型
  	--信用卡不能向储蓄卡转账；
      if a_type='信用卡' and r_type='储蓄卡' 
      then return_code:=0;return 0;
      end if;
      select b_balance into balance from bank_card where b_number=source_card_id;
  	--转账金额不能超过储蓄卡余额；
      if balance<amount 
      then return_code:=0;return 0;
      end if;
      update bank_card set b_balance=b_balance-amount where b_number=source_card_id;
      if r_type='信用卡' then update bank_card set b_balance=b_balance-amount where b_number=dest_card_id;
      else update bank_card set b_balance=b_balance+amount where b_number=dest_card_id;
      end if;
      commit;
      return_code:=1;return 1;
  end; 
  /*  end  of  your code  */ 
  ```

## 触发器

#### 触发器

触发器是与某个表绑定的命名存储对象，与存储过程一样，它由一组语句组成，当这个表上发生某个操作(insert,delete,update)时，触发器被触发执行。触发器一般用于实现业务完整性规则。当primary key,foreigh key, check等约束都无法实现某个复杂的业务规则时，可以考虑用触发器来实现。

#### 触发器的创建

创建触发器的语句： `CREATE  TRIGGER trigger_name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }` `ON table_name` `[ FROM referenced_table_name ]` `{ NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }` `[ FOR [ EACH ] { ROW | STATEMENT } ] [ WHEN ( condition ) ]` `EXECUTE PROCEDURE function_name ( arguments );`

- trigger_nme: 每个触发器有一个唯一的命名
- trigger_time: 触发的时机，二选一： BEFORE | AFTER  
- trigger_event: 触发事件，四选一： INSERT | UPDATE | DELETE |TRUNCATE
- tbl_name: 与触发器绑定的表
- function_name: 触发器体由函数定义。但是必须声明为不带参数并返回类型为触发器。具体函数声明的方法参考OpenGauss函数实训。

与创建存储过程、函数一样，创建触发器时也要用delimiter语句重新指定触发器定义语句的界符(触发器内语句的分隔符仍为分号)，在触发器定义之后，再把界符更改回去。

**before与after触发器的区别:**

- before触发器在试图激活触发器的那条语句(insert|delete|update|truncate)之前执行。
- after触发器仅在before触发器(如果有的话)和试图激活触发器的那条语句都成功执行后才执行。
- before触发器或after触发器如果未能成功执行，则激活触发器的语句也不会执行。

#### 触发器内的特殊变量

在触发器内可以使用两类特殊变量：

- OLD.  UPDATE及DELETE操作涉及tuple信息 中的旧值，对INSERT为空。
- NEW. INSERT及UPDATE操作涉及tuple信息 中的新值，对DELETE为空。
- 其它特殊变量.参考OpenGauss手册。



**任务：**

为表property(资产表)编写一个触发器，以实现以下完整性业务规则：

- 如果pro_type = 1, 则pro_pif_id只能引用finances_product表的p_id；
- 如果pro_type = 2, 则pro_pif_id只能引用insurance表的i_id；
- 如果pro_type = 3, 则pro_pif_id只能引用fund表的f_id；
- pro_type不接受(1,2,3)以外的值。

各投资品种一经销售，不会再改变；

```
--创建触发器函数TRI_INSERT_FUNC()
CREATE OR REPLACE FUNCTION TRI_INSERT_FUNC() RETURNS TRIGGER AS
$$
DECLARE
   --此处用declare语句声明你所需要的变量
BEGIN
   --此处插入触发器业务
   --如果pro_type = 1, 则pro_pif_id只能引用finances_product表的p_id；
   if new.pro_type=1
   then 
   if not exists(select * from finances_product where new.pro_pif_id=p_id)
   then raise exception '%',concat('finances product #',to_char(new.pro_pif_id),' not found!');
   end if;
   --如果pro_type = 2, 则pro_pif_id只能引用insurance表的i_id；
   elseif new.pro_type=2
   then
      if not exists(select * from insurance where new.pro_pif_id=i_id)
         then raise exception '%',concat('insurance #',to_char(new.pro_pif_id),' not found!');
   end if;
   --如果pro_type = 3, 则pro_pif_id只能引用fund表的f_id；
   elseif new.pro_type=3
   then
      if not exists(select * from fund where new.pro_pif_id=f_id)
         then raise exception '%',concat('fund #',to_char(new.pro_pif_id),' not found!');
   end if;
   --pro_type不接受(1,2,3)以外的值。
   else
      raise exception '%',concat('type',' ',to_char(new.pro_type),' ','is illegal!');
   end if;
   --触发器业务结束
   return new;--返回插入的新元组
END;
$$ LANGUAGE PLPGSQL;

-- 创建before_property_inserted触发器，使用函数TRI_INSERT_FUNC实现触发器逻辑：
CREATE  TRIGGER before_property_inserted BEFORE INSERT ON property
FOR EACH ROW 
EXECUTE PROCEDURE TRI_INSERT_FUNC();
```

## 用户自定义函数

### 函数定义和应用

函数其实有多种，比如标量函数(仅返回一个值)和表函数(返回结果是表),语法也各不相同。这里，我们仅给出一个简化的创建标量函数的语法:

create function语句的语法：

create function function_name([para data_type[,...]]) returns data_type begin    function_body;    return expression;  end

- function_name:函数名；
- para:参数名；
- data_type:参数的数据类型；
- 一个函数可以没有参数，也可以有多个。多参数间用逗号分隔。
- function_body:函数体。即由合法的SQL语句组成的程序段。
- expression:函数返回值，可以是常量、表达式，甚至是一条select语句查询的值（必须保证结果唯一);该值类型应与returns短语定义的类型相同。

函数一旦定义，就可以像内部函数一样使用，比如出现在select列表、表达式、以及where子句的条件中。



任务：

(1) 用create function语句创建符合以下要求的函数：

- 依据客户编号计算其所有储蓄卡余额的总和。
- 函数名为：get_deposit

(2) 利用创建的函数，仅用一条SQL语句查询存款总额在100万(含)以上的客户身份证号，姓名和存款总额(total_deposit)，结果依存储总额从高到低排序。

```

/*
   用create function语句创建符合以下要求的函数：
   依据客户编号计算该客户所有储蓄卡的存款总额。
   函数名为：get_Records。函数的参数名可以自己命名:*/

CREATE OR REPLACE FUNCTION get_deposit(client_id integer) 
 returns numeric(10,2)
 LANGUAGE plpgsql
AS
$$
--声明变量的地方
declare num numeric(10,2);
--函数体
begin
   num:=(select sum(b_balance) from bank_card where b_type='储蓄卡' and b_c_id=client_id group by b_c_id);
   return num;
end;
$$;

/*  应用该函数查询存款总额在100万(含)以上的客户身份证号，姓名和存储总额(total_deposit)，
    结果依存款总额从高到代排序  */
    select c_id_card,c_name,total_deposit from(
        select c_id_card,c_name,get_deposit(c_id) as total_deposit
        from client
        order by total_deposit desc
    ) where total_deposit id not null and total_deposit>=1000000;

/*  代码文件结束     */
/*  代码文件结束     */
```

## 安全性控制



## 并发控制与事务的隔离级别



## 数据库应用开发JAVA



## 备份+日志



## 数据库设计与实现



## 数据库索引B+树实现



