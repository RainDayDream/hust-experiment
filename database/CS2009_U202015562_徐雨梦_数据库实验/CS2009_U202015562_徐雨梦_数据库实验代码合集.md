# 数据库实验CS2009_U202015562_徐雨梦

以下为题目和代码（含注释）

平台openguass

### 命令行连接数据库

```
gsql -h 127.0.0.1 -d postgres -U gaussdb -W'Passwd123@123'
```

## 数据库、表与完整性约束定义 Create

```
第一关
创建数据库：
CREATE DATABASE beijing2022;

第二关
创建表及主码约束
    CREATE TABLE t_emp
    (
        id INT PRIMARY KEY,
        name VARCHAR(32),
        deptid INT,
        salary FLOAT
    );

第三关
创建外码约束
    CREATE TABLE dept
    (
        deptNo INT PRIMARY KEY,
        deptName VARCHAR(32)
    );

    CREATE TABLE staff
    (
        staffNo INT PRIMARY KEY,
        staffName VARCHAR(32),
        gender CHAR(1),
        dob date,
        Salary numeric(8,2),
        deptNo INT,
        CONSTRAINT FK_staff_deptNo FOREIGN KEY(deptNo) REFERENCES dept(deptNo)
    );
    
第四关
创建check约束
CREATE TABLE products
(
    pid CHAR(10) PRIMARY KEY,
    name VARCHAR(32),
    brand CHAR(10),
    price INT
    CONSTRAINT CK_products_brand CHECK(brand in('A','B')),
    CONSTRAINT CK_products_price CHECK(price>0)
);

第五关
创建default约束
CREATE TABLE hr
(
    id CHAR(10) PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    mz CHAR(16) default('汉族')
);

第六关
创建unique约束
CREATE TABLE s
(
    sno CHAR(10) PRIMARY KEY,
    name VARCHAR(32) NOT NULL,
    ID CHAR(18) UNIQUE
);
```

## 表结构和完整性约束的修改 Alter

- 第一关

  修改表名

  ```
  ----请在以下空白处添加恰当的语句，将表名your_table更改为my_table:
  ALTER TABLE your_table RENAME TO my_table;
  ```

- 第二关

  添加与删除字段

  ```
  ----语句1：删除表orderDetail中的列orderDate
  ALTER TABLE orderDetail DROP orderDate;
  ----语句2：添加列unitPrice
  ALTER TABLE orderDetail ADD unitPrice NUMERIC(10,2);
  ```

- 第三关

  修改字段

  ```
  ----请在以下空白处添加适当的SQL语句，实现编程要求
  ----将QQ号的数据类型改为char(12);
  ----增加一列，列名为wechat，数据类型是char(12)。
  ALTER TABLE addressBook MODIFY QQ CHAR(12),
  ADD wechat CHAR(12);

- 第四关

  添加、删除与修改约束

  ```
  ---(1) 为表Staff添加主码
  ALTER TABLE Staff ADD PRIMARY KEY (staffNo);
  ---(2) Dept.mgrStaffNo是外码，对应的主码是Staff.staffNo,请添加这个外码，名字为FK_Dept_mgrStaffNo:
  ALTER TABLE Dept ADD CONSTRAINT FK_Dept_mgrStaffNo FOREIGN KEY (mgrStaffNo)REFERENCES Staff(staffNo);
  ---(3) Staff.dept是外码，对应的主码是Dept.deptNo. 请添加这个外码，名字为FK_Staff_dept:
  ALTER TABLE Staff ADD CONSTRAINT FK_Staff_dept FOREIGN KEY (dept) REFERENCES dept(deptno);
  ---(4) 为表Staff添加check约束，规则为：gender的值只能为F或M；约束名为CK_Staff_gender:
  ALTER TABLE Staff ADD CONSTRAINT CK_Staff_gender CHECK(gender = ANY (ARRAY['F'::bpchar, 'M'::bpchar]));
  ---(5) 为表Dept添加unique约束：deptName不允许重复。约束名为UN_Dept_deptName：
  ALTER TABLE Dept ADD CONSTRAINT UN_Dept_deptName UNIQUE (deptName);

## 数据查询 Select

本实训采用的是某银行的一个金融场景应用的模拟数据库，数据库中表，表结构以及所有字段的说明如下：

![表1](./image/%E8%A1%A81.png)

![表2](./image/%E8%A1%A82.png)

![表3](./image/%E8%A1%A83.png)

![表4](./image/%E8%A1%A84.png)

![表5](./image/%E8%A1%A85.png)

![表6](./image/%E8%A1%A86.png)



- 第一关

  查询客户主要信息

  **SELECT的用法**

  ``` 
  -- 1) 查询所有客户的名称、手机号和邮箱信息。查询结果按照客户编号排序。
  SELECT c_name,c_phone,c_mail FROM client ORDER BY c_id;

- 第二关

  查询邮箱为null的用户

  **WHERE的用法**

  ```
  -- 2) 查询客户表(client)中邮箱信息为null的客户的编号、名称、身份证号、手机号。
  SELECT c_id,c_name,c_id_card,c_phone FROM client WHERE c_mail IS NULL;

- 第三关

  查询既买了保险又买了基金的客户

  **采用了with来生成子表方便where查询，使用了exists**

  ```
  -- 3) 查询既买了保险又买了基金的客户的名称、邮箱和电话。结果依c_id排序
  WITH BAOXIAN AS (SELECT pro_c_id FROM property WHERE pro_type=2),--生成买了保险的客户表
  LICAI AS (SELECT pro_c_id FROM property WHERE pro_type=3) --生成买了基金的客户表
  SELECT c_name,c_mail,c_phone FROM client --从全部客户中筛选
  WHERE EXISTS (SELECT pro_c_id FROM BAOXIAN WHERE pro_c_id=client.c_id)--买了保险，在保险这个表中存在 
  AND --同时满足
  EXISTS (SELECT pro_c_id FROM LICAI WHERE pro_c_id=client.c_id);--买了基金，在基金这个表中存在 

- 第四关

  办理了**储蓄卡**的用户信息

  ```
  -- 4) 查询办理了储蓄卡的客户名称、手机号、银行卡号。 查询结果结果依客户编号排序。
  SELECT c_name,c_phone,b_number FROM client,bank_card WHERE b_c_id=c_id AND b_type='储蓄卡';

- 第五关

  每份金额在3000-5000之间的理财产品

  ```
  -- 5) 查询理财产品中每份金额在30000～50000之间的理财产品的编号,每份金额，理财年限，并按照金额升序排序，金额相同的按照理财年限降序排序。
  SELECT p_id,p_amount,p_year FROM finances_product WHERE p_amount BETWEEN 30000 AND 50000 ORDER BY p_amount,p_year DESC;

- 第六关

  商品收益的众数

  **子查询的使用**

  ```
  -- 6) 查询资产表中所有资产记录里商品收益的众数和它出现的次数。
  WITH RESULT AS(SELECT pro_income,COUNT(pro_income) AS presence FROM property GROUP BY pro_income)--生成收益和它的数量，其中数量命名为presence
  SELECT pro_income,presence FROM RESULT WHERE presence=(SELECT MAX(presence)FROM RESULT);--采用聚合函数max找到最大的数，并筛选出众数

- 第七关

  未购买任何理财产品的武汉居民

  **NOT EXISTS的使用**

  ```
  -- 7) 查询身份证隶属武汉市没有买过任何理财产品的客户的名称、电话号、邮箱。
  SELECT c_name,c_phone,c_mail FROM client WHERE c_id_card LIKE '4201%' AND NOT EXISTS (SELECT pro_c_id FROM property WHERE c_id=pro_c_id AND pro_type=1);

- 第八关

  持有两张信用卡的用户

  **聚集函数count的使用**

  ```
  -- 8) 查询持有两张(含）以上信用卡的用户的名称、身份证号、手机号。
  WITH BIAO AS(SELECT b_c_id FROM bank_card GROUP BY b_c_id,b_type HAVING COUNT(b_number)>=2 AND b_type='信用卡')
  SELECT c_name,c_id_card,c_phone FROM client WHERE EXISTS(SELECT b_c_id FROM BIAO WHERE c_id=b_c_id);

- 第九关

  购买了货币型基金的客户信息

  **子查询和any的使用**

  ```
  -- 9) 查询购买了货币型(f_type='货币型')基金的用户的名称、电话号、邮箱。
  SELECT c_name,c_phone,c_mail FROM client WHERE c_id=ANY(SELECT pro_c_id FROM property WHERE pro_pif_id=ANY(SELECT f_id FROM fund WHERE f_type='货币型')AND pro_type=3);

- 第十关

  投资总收益前三名的用户

  **LIMIT的使用**

  ```
  -- 10) 查询当前总的可用资产收益(被冻结的资产除外)前三名的客户的名称、身份证号及其总收益，按收益降序输出，总收益命名为total_income。不考虑并列排名情形。
  WITH SHOURU AS(SELECT pro_c_id,SUM(pro_income)AS total_income FROM property GROUP BY pro_c_id,pro_status HAVING pro_status='可用')
  SELECT c_name,c_id_card,total_income FROM client,SHOURU WHERE c_id=pro_c_id ORDER BY total_income DESC LIMIT 3;

- 第11关

  黄姓客户持卡数量

  **like的使用和left outer join的使用**

  ```
  -- 11) 给出黄姓用户的编号、名称、办理的银行卡的数量(没有办卡的卡数量计为0),持卡数量命名为number_of_cards,
  --     按办理银行卡数量降序输出,持卡数量相同的,依客户编号排序。
  select c_id,c_name, count(b_c_id)number_of_cards
  from client left outer join bank_card on (b_c_id=c_id)--将银行的信息和客户的信息合并方便查询
  group by c_id--按照用户分组
  having c_name LIKE '黄%'--筛选黄姓用户
  order by c_id,number_of_cards DESC;

- 第12关

  客户理财、保险与基金投资总额

  **聚合函数sum的使用**

  ```
   -- 12) 综合客户表(client)、资产表(property)、理财产品表(finances_product)、保险表(insurance)和
   --     基金表(fund)，列出客户的名称、身份证号以及投资总金额（即投资本金，
   --     每笔投资金额=商品数量*该产品每份金额)，注意投资金额按类型需要查询不同的表，
   --     投资总金额是客户购买的各类资产(理财,保险,基金)投资金额的总和，总金额命名为total_amount。
   --     查询结果按总金额降序排序。
  WITH ZICHAN AS
  (SELECT pro_c_id,sum(pro_quantity*pro_amount) total_amount 
  FROM(SELECT pro_id,pro_c_id,pro_quantity,p_amount AS pro_amount FROM property,finances_product WHERE p_id=pro_pif_id AND pro_type=1
  UNION 
  SELECT pro_id,pro_c_id,pro_quantity,i_amount AS pro_amount FROM property,insurance WHERE i_id=pro_pif_id AND pro_type=2
  UNION
  SELECT pro_id,pro_c_id,pro_quantity,f_amount AS pro_amount FROM property,fund WHERE f_id=pro_pif_id AND pro_type=3)--生成一个用户的资产表，不区分资产类型，只包含资产的数量和金额
  GROUP BY pro_c_id)--该部分为with部分的子表 ZICHAN ,生成一个表，只有用户和持有资产总额
  SELECT c_name,c_id_card,total_amount FROM client INNER JOIN ZICHAN ON c_id=pro_c_id 
  UNION
  SELECT c_name,c_id_card,0 total_amount FROM client WHERE NOT EXISTS (SELECT pro_c_id FROM ZICHAN WHERE c_id=pro_c_id)--union没有资产的人
  ORDER BY total_amount DESC;

- 第13关

  客户总资产

  ```
  -- 13) 综合客户表(client)、资产表(property)、理财产品表(finances_product)、
  --     保险表(insurance)、基金表(fund)和投资资产表(property)，
  --     列出所有客户的编号、名称和总资产，总资产命名为total_property。
  --     总资产为储蓄卡余额，投资总额，投资总收益的和，再扣除信用卡透支的金额
  --     (信用卡余额即为透支金额)。客户总资产包括被冻结的资产。
  WITH ZICHAN AS
  (SELECT pro_c_id,sum(pro_quantity*pro_amount+pro_income) total_amount 
  FROM(SELECT pro_id,pro_c_id,pro_quantity,p_amount AS pro_amount,pro_income FROM property,finances_product WHERE p_id=pro_pif_id AND pro_type=1
  UNION 
  SELECT pro_id,pro_c_id,pro_quantity,i_amount AS pro_amount,pro_income FROM property,insurance WHERE i_id=pro_pif_id AND pro_type=2
  UNION
  SELECT pro_id,pro_c_id,pro_quantity,f_amount AS pro_amount,pro_income FROM property,fund WHERE f_id=pro_pif_id AND pro_type=3)
  GROUP BY pro_c_id),//子表ZICHAN
  TOUZI AS
  (SELECT c_id,c_name,total_amount FROM client INNER JOIN ZICHAN ON c_id=pro_c_id 
  UNION
  SELECT c_id,c_name,0 total_amount FROM client WHERE NOT EXISTS (SELECT pro_c_id FROM ZICHAN WHERE c_id=pro_c_id)),//子表TOUZI
  YINHANG AS
  (SELECT b_c_id,SUM(card_balance) total_balance FROM(SELECT b_number,b_c_id,b_balance card_balance FROM bank_card WHERE b_type='储蓄卡'
  UNION
  SELECT b_number,b_c_id,b_balance*(-1) card_balance FROM bank_card WHERE b_type='信用卡') GROUP BY b_c_id)//子表YINHANG
  SELECT c_id,c_name,total_amount+total_balance total_property FROM TOUZI,YINHANG WHERE c_id=b_c_id 
  UNION
  SELECT c_id,c_name,0 total_property FROM TOUZI WHERE NOT EXISTS (SELECT b_c_id FROM YINHANG WHERE c_id=b_c_id)//union上三个子表没有的人
  ORDER BY c_id;

- 第14关

  第N高问题

  **LIMIT n OFFSET m的用法：找到从第m个开始的n条记录 **

  ```
  -- 14) 查询每份保险金额第4高保险产品的编号和保险金额。
  --     在数字序列8000,8000,7000,7000,6000中，
  --     两个8000均为第1高，两个7000均为第2高,6000为第3高。
  SELECT i_id,i_amount FROM insurance WHERE i_amount=(SELECT i_amount FROM ( SELECT DISTINCT i_amount FROM insurance ) ORDER BY i_amount DESC LIMIT 1 OFFSET 3) ORDER BY i_id;

- 第15关

  基金收益两种方式排名

  **RANK函数和DENSE_RANK函数**

  ```
  -- 15) 查询资产表中客户编号，客户基金投资总收益,基金投资总收益的排名(从高到低排名)。
  --     总收益相同时名次亦相同(即并列名次)。总收益命名为total_revenue, 名次命名为rank。
  --     第一条SQL语句实现全局名次不连续的排名，
  --     第二条SQL语句实现全局名次连续的排名。
  -- (1) 基金总收益排名(名次不连续)
  SELECT pro_c_id,SUM(pro_income) total_revenue,RANK() OVER(ORDER BY total_revenue DESC)AS rank FROM property WHERE pro_type=3 GROUP BY pro_c_id  ORDER BY total_revenue DESC,pro_c_id;
  -- (2) 基金总收益排名(名次连续)
  SELECT pro_c_id,SUM(pro_income) total_revenue,DENSE_RANK() OVER(ORDER BY total_revenue DESC)AS rank FROM property WHERE pro_type=3 GROUP BY pro_c_id  ORDER BY total_revenue DESC,pro_c_id;

- 第16关

  持有完全相同基金组合的客户

  **选出一个用户的基金数量，用另一个表去除**

  ```
  -- 16) 查询持有相同基金组合的客户对，如编号为A的客户持有的基金，编号为B的客户也持有，反过来，编号为B的客户持有的基金，编号为A的客户也持有，则(A,B)即为持有相同基金组合的二元组，请列出这样的客户对。为避免过多的重复，如果(1,2)为满足条件的元组，则不必显示(2,1)，即只显示编号小者在前的那一对，这一组客户编号分别命名为c_id1,c_id2。
  WITH T1 AS(SELECT c_id c_id1 FROM client),T2 AS(SELECT c_id c_id2 FROM client)
  SELECT c_id1,c_id2 FROM T1,T2 WHERE c_id1<c_id2 
  AND EXISTS(SELECT pro_c_id FROM property WHERE pro_c_id=c_id1 AND pro_type=3) 
  AND EXISTS(SELECT pro_c_id FROM property WHERE pro_c_id=c_id2 AND pro_type=3) --筛选买了基金的人
  AND NOT EXISTS(
  (SELECT FUND1 FROM (SELECT  pro_pif_id FUND1 FROM property WHERE pro_type=3 AND pro_c_id=c_id1)AS T3(FUND1) WHERE NOT EXISTS (SELECT pro_pif_id  FROM property WHERE pro_type=3 AND pro_c_id=c_id2 AND pro_pif_id=T3.FUND1))
  )--t1的用户基金t2中用户都包含
  AND NOT EXISTS(
  (SELECT FUND2 FROM (SELECT  pro_pif_id FUND2 FROM property WHERE pro_type=3 AND pro_c_id=c_id2)AS T4(FUND2) WHERE NOT EXISTS (SELECT pro_pif_id  FROM property WHERE pro_type=3 AND pro_c_id=c_id1 AND pro_pif_id=T4.FUND2)));--t2的用户基金t1中用户都包含，取交集就是相等

- 第17关

  购买基金的高峰期

  **TO_CHAR是将日期转换成字符串，再用LIKE进行匹配比较；extract是将日期转换为周几的函数，0表示周日，123456表示周一二三四五六**

  **三种情况：①该天的前两天；②该天的前后各一天；③该天的后两天。要么是周六日要么超过1000000**

  ```
  -- 17 查询2022年2月购买基金的高峰期。至少连续三个交易日，所有投资者购买基金的总金额超过100万(含)，则称这段连续交易日为投资者购买基金的高峰期。只有交易日才能购买基金,但不能保证每个交易日都有投资者购买基金。2022年春节假期之后的第1个交易日为2月7日,周六和周日是非交易日，其余均为交易日。请列出高峰时段的日期和当日基金的总购买金额，按日期顺序排序。总购买金额命名为total_amount。
  
  WITH T1 AS
  (SELECT pro_purchase_time,SUM(pro_quantity*f_amount) amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING amount>1000000 AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time),
  T2 AS
  (SELECT pro_purchase_time p_time,SUM(pro_quantity*f_amount) amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING amount>1000000 AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time)
  SELECT pro_purchase_time,amount FROM(
  (SELECT pro_purchase_time,amount FROM T1 WHERE 
  ((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-2) OR (extract(dow from pro_purchase_time-2)=6) OR (extract(dow from pro_purchase_time-2)=0))
  AND
  (EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-1) OR (extract(dow from pro_purchase_time-1)=6) OR (extract(dow from pro_purchase_time-1)=0)))
  )
  UNION
  (SELECT pro_purchase_time,amount FROM T1 WHERE
  ((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+1) OR (extract(dow from pro_purchase_time+1)=6) OR (extract(dow from pro_purchase_time+1)=0))
  AND
  (EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time-1) OR (extract(dow from pro_purchase_time-1)=6) OR (extract(dow from pro_purchase_time-1)=0)))
  )
  UNION
  (SELECT pro_purchase_time,amount FROM T1 WHERE
  ((EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+2) OR (extract(dow from pro_purchase_time+2)=6) OR (extract(dow from pro_purchase_time+2)=0))
  AND
  (EXISTS(SELECT p_time FROM T2 WHERE p_time=pro_purchase_time+1) OR (extract(dow from pro_purchase_time+1)=6) OR (extract(dow from pro_purchase_time+1)=0)))
  )
  ) ORDER BY pro_purchase_time;

- 第18关

  **至少有一张信用卡**金额超过5000元的客户信用卡总金

  **即最大金额超过即可**

  ```
   -- 18) 查询至少有一张信用卡余额超过5000元的客户编号，以及该客户持有的信用卡总余额，总余额命名为credit_card_amount。
  SELECT b_c_id,SUM(b_balance) credit_card_amount FROM bank_card WHERE b_type='信用卡' GROUP BY b_c_id HAVING MAX(b_balance)>5000 ORDER BY b_c_id;

- 第19关

  以日历表格式显示每日基金购买总金额

  分组统计； 日期函数的应用； if或case函数的用法； 有规律的行列转换。

  - date_part('week',d1) - 日期d1在当年的周次。week('2022-2-7') = 6;
  - extract(DOW FROM cast(d1 as TIMESTAMP) - 返回d1在本周的次序(0 = Sunday, 1 = Monday, …, 6 = Saturday)
  - case when expr1 then expr2 else expr3 end - 若expr1为TRUE，返回expr2，否则返回expr3.

  ```
  -- 19) 以日历表格式列出2022年2月每周每日基金购买总金额，输出格式如下：
  -- week_of_trading Monday Tuesday Wednesday Thursday Friday
  --               1
  --               2    
  --               3
  --               4
  --   请用一条SQL语句实现该查询：
  WITH GOUMAI AS
  (SELECT pro_purchase_time,SUM(pro_quantity*f_amount) total_amount FROM property,fund WHERE pro_type=3 AND pro_pif_id=f_id GROUP BY pro_purchase_time HAVING TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2022-02-%' ORDER BY pro_purchase_time),
  --把购买时间和金额筛选出来
  T1 AS
  (SELECT DATE_PART('WEEK',pro_purchase_time)-5 week_of_trading,
  (CASE WHEN extract(dow from pro_purchase_time)=1 THEN total_amount END) AS Monday,
  (CASE WHEN extract(dow from pro_purchase_time)=2 THEN total_amount END) AS Tuesday,
  (CASE WHEN extract(dow from pro_purchase_time)=3 THEN total_amount END) AS Wendnesday,
  (CASE WHEN extract(dow from pro_purchase_time)=4 THEN total_amount END) AS Thursday,
  (CASE WHEN extract(dow from pro_purchase_time)=5 THEN total_amount END) AS Friday FROM  GOUMAI),
  --把日期集中在T1这个表中
  MONDAY AS(
      SELECT week_of_trading,Monday FROM T1 WHERE Monday IS NOT NULL
  ),
  --找星期一的金额
  TUESDAY AS(
      SELECT week_of_trading,Tuesday FROM T1 WHERE Tuesday IS NOT NULL
  ),
  --找星期二的金额
  WEDNESDAY AS(
      SELECT week_of_trading,Wendnesday FROM T1 WHERE Wendnesday IS NOT NULL
  ),
  --找星期三的金额
  THURSDAY AS(
      SELECT week_of_trading,Thursday FROM T1 WHERE Thursday IS NOT NULL
  ),
  --找星期四的金额
  FRIDAY AS(
      SELECT week_of_trading,Friday FROM T1 WHERE Friday IS NOT NULL
  )
  --找星期五的金额
  SELECT MONDAY.week_of_trading,Monday,Tuesday,Wendnesday,Thursday,Friday FROM MONDAY LEFT OUTER JOIN TUESDAY ON MONDAY.week_of_trading=TUESDAY.week_of_trading LEFT OUTER JOIN WEDNESDAY ON MONDAY.week_of_trading=WEDNESDAY.week_of_trading LEFT OUTER JOIN THURSDAY ON MONDAY.week_of_trading=THURSDAY.week_of_trading LEFT OUTER JOIN FRIDAY ON MONDAY.week_of_trading=FRIDAY.week_of_trading;
  --周1、2、3、4、5合起来，这个样例中用left outer join即可，但普遍情况应该left outer join和right outer join筛选出来两个表然后union一下
  
  /*  end  of  your code  */

- 第20关

  查询销售总额前三的理财产品

   查询**2010年和2011年这两年每年销售总额前3名**（如果有并列排名，则后续排名号跳过之前的并列排名个数，例如1、1、3）的统计年份（pyear）、销售总额排名值(rk)、理财产品编号(p_id)、销售总额(sumamount)。   注意结果输出要求：(1)按照年份升序排列，同一年份按照销售总额的排名值升序排列，如遇到并列排名则按照理财产品编号升序排列;(2)属性显示：统计年份（pyear）、销售总额排名值(rk)、理财产品编号(p_id)、销售总额(sumamount)（3）结果显示顺序：先按照统计年份（pyear）升序排,同一年份按照销售总额排名值（rk）升序排,同一排名值的按照理财产品编号（p_id ）升序排。

  **使用的语法：**

  **嵌套查询； rank() over(partition by ...order by)的使用。**

  ```
  -- 20) 查询销售总额前三的理财产品
  --   请用一条SQL语句实现该查询：
  (SELECT pyear,rank()over(partition by pyear order by sumamount DESC) rk,p_id,sumamount FROM
  (
  SELECT p_id, 2010 pyear,pro_quantity*p_amount sumamount FROM property,finances_product WHERE  pro_type=1 AND p_id=pro_pif_id AND TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2010%'
  )--从property和finances_product两个表中筛选出来理财产品2010年购买的编号、金额、时间
  ORDER BY pyear,sumamount DESC LIMIT 3)--排序并选出来前三个
  
  UNION--将2010年和2011年俩表合并得到最后的表
  
  (SELECT pyear,rank()over(partition by pyear order by sumamount DESC) rk,p_id,sumamount FROM
  (
  SELECT p_id,2011 pyear,pro_quantity*p_amount sumamount FROM property,finances_product WHERE  pro_type=1 AND p_id=pro_pif_id AND  TO_CHAR(pro_purchase_time,'yyyy-mm-dd') LIKE '2011%'
  )--从property和finances_product两个表中筛选出来理财产品2011年购买的编号、金额、时间
  ORDER BY pyear,sumamount DESC LIMIT 3)--排序并选出来前三个
  ;
  --/*  end  of  your code  */
  ```

- 第21关

  投资积极且偏好理财类产品的客户

  题目详情：购买了**3种（同一编号的理财产品记为一种）以上理财产品**的客户被认为投资积极的客户，若该客户**持有基金产品种类数（同一基金编号记为相同的基金产品种类）小于其持有的理财产品种类数**，则认为该客户为投资积极且偏好理财产品的客户。查询所有此类客户的编号(pro_c_id)。 注意结果输出要求：按照客户编号的**升序排列**，且**去除重复**结果。

  ```
  -- 21) 投资积极且偏好理财类产品的客户
  --   请用一条SQL语句实现该查询：
  WITH T1 AS
  (SELECT pro_c_id,count(*) financenum FROM property WHERE pro_type=1 GROUP BY pro_c_id HAVING count(*)>3),--找到理财产品拥有三个以上的id并记录数量
  T2 AS
  (SELECT pro_c_id,count(*) fundnum FROM property WHERE pro_type=3 GROUP BY pro_c_id)--找到基金拥有的数量
  SELECT T1.pro_c_id FROM T1,T2 WHERE financenum>fundnum AND T1.pro_c_id=T2.pro_c_id;--删选出来理财产品数量＞基金数量的id
  --/*  end  of  your code  */
  ```

- 第22关

  查询购买了所有畅销理财产品的客户

  若定义**持有人数超过2的理财产品**称为畅销理财产品。查询**购买了所有畅销理财产品的**客户编号(pro_c_id)。 注意结果输出要求：按照客户编号的升序排列，且去除重复结果。

  ```
  -- 22) 查询购买了所有畅销理财产品的客户
  --   请用一条SQL语句实现该查询：
  WITH CX AS(
      SELECT DISTINCT pro_pif_id FROM property  WHERE pro_type=1 GROUP BY pro_pif_id HAVING COUNT(*)>2)--CX保存了畅销产品的id
  CXCLINET AS(
  SELECT DISTINCT pro_c_id FROM property WHERE pro_type=1)--CXCLIENT保存了购买了理财产品的id
  SELECT pro_c_id FROM CXCLINET WHERE NOT EXISTS(
      SELECT pro_pif_id FROM CX WHERE NOT EXISTS(
          SELECT pro_pif_id FROM property WHERE pro_type=1 AND property.pro_c_id=CXCLINET.pro_c_id AND property.pro_pif_id=CX.pro_pif_id
      )--查找该pro_c_id下没有购买的畅销理财产品的表
  )--该表如果不存在那么就是购买了所有的畅销理财产品
  ;
  --/*  end  of  your code  */
  ```

- 第23关

  查找相似的理财产品

  在某些推荐方法中，需要查找某款理财产品相似的其他理财产品，不妨设其定义为：对于某款理财产品A，可找到**持有A数量最多的“3”个**（包括所有持有相同数量的客户，因此如有3个并列第一、1个第二、一个第三，则排列结果是1,1,1,2,3）客户，然后对于**这“3”个客户持有的所有理财产品**（不包含产品A自身），每款产品被全体客户**持有总人数被认为是和产品A的相似度，**若有相似度相同的理财产品，则为了便于后续处理的确定性，则这些相似度相同的理财产品间按照产品编号的升序排列。按照和产品A的相似度，**最多的“3”款（同上理，前3名允许并列的情况，例如排列结果是1,2,2,2,3）理财产品，就是产品A的相似的理财产品。** 

  请查找产品14的相似理财产品编号（不包含14自身）（pro_pif_id）、该编号的理财产品的客购买客户总人数（cc）以及该理财产品对于14  号理财产品的相似度排名值（prank）。 注意结果输出要求：**按照相似度值降序排列**，相同相似度的理财产品之间则按照产品编号的升序排列。

  ```
  -- 23) 查找相似的理财产品
  --   请用一条SQL语句实现该查询：
  
  WITH CLIENT14 AS(
       SELECT pro_c_id,DENSE_RANK() OVER(PARTITION BY pro_pif_id ORDER BY pro_quantity DESC) AS rk FROM property WHERE pro_type=1 AND pro_pif_id=14 
  ),--购买了14号理财产品的客户名单
  T1 AS(
       SELECT DISTINCT pro_pif_id FROM property WHERE pro_type=1 AND EXISTS(SELECT pro_c_id FROM CLIENT14 WHERE pro_c_id=property.pro_c_id AND rk<=3)
  )--购买了14号理财产品的客户所购买的理财产品单子
  SELECT DISTINCT pro_pif_id,COUNT(*) cc,DENSE_RANK()OVER(ORDER BY cc DESC) AS prank FROM property WHERE pro_type=1 AND pro_pif_id!=14 AND EXISTS(
       SELECT pro_pif_id FROM T1 WHERE pro_pif_id=property.pro_pif_id
  )
  GROUP BY pro_pif_id;--对存在与T1表的理财产品排序
  --/*  end  of  your code  */
  ```

- 第24关

  查询任意两个客户的相同理财产品数

  查询**任意两个客户之间持有的相同理财产品种数**，并且结果仅保留相同理财产品数至少2种的用户对。  注意结果输出要求：第一列和第二列输出客户编号(pro_c_id,pro_c_id)，第三列输出他们持有的相同理财产品数(total_count)，按照第一列的客户编号的升序排列。

  ```
  -- 24) 查询任意两个客户的相同理财产品数
  --   请用一条SQL语句实现该查询：
  WITH T1 AS(
        SELECT pro_c_id,pro_pif_id FROM property WHERE pro_type=1
  ),//购买了理财产品的客户与理财产品表
  T2 AS(
        SELECT property.pro_c_id id1,T1.pro_c_id id2,property.pro_pif_id FROM property,T1 WHERE pro_type=1 AND property.pro_pif_id=T1.pro_pif_id AND property.pro_c_id!=T1.pro_c_id
  )//购买了相同的理财产品的用户和所购买的相同的理财产品表
  SELECT id1 pro_c_id,id2 pro_c_id,COUNT(*) total_count FROM T2 GROUP BY id1,id2 HAVING COUNT(*)>=2 ORDER BY id1;
  ;//查找购买了>=2的相同产品的客户
  --/*  end  of  your code  */
  ```

- 第25关

  查询相似的理财客户
  
   在某些推荐方法中，需要**查找某位客户在理财行为上相似的其他客户**，不妨设其定义为：对于A客户，其购买的理财产品集合为{P}，另所有买过{P}中至少一款产品的其他客户集合为{B}，则{B}中每位用户购买的{P}中产品的数量为他与A客户的相似度值。将{B}中客户按照相似度值降序排列，得到A客户的相同相似度值则按照客户编号升序排列，这样取前两位客户即为A客户的相似理财客户列表。   
  
  任务：查询每位客户(列名：pac)的相似度排名值小于3的相似客户(列名：pbc)列表，以及该每位客户和他的每位相似客户的共同持有的理财产品数(列名：common)、相似度排名值(列名：crank)。 
  
   注意结果输出要求：要求结果先按照左边客户编号(pac)升序排列，同一个客户的相似客户则按照客户相似度排名值（crank）顺序排列。
  
  ```
  -- 25) 查找相似的理财客户
  --   请用一条SQL语句实现该查询：
  WITH T1 AS(
        SELECT pro_c_id,pro_pif_id FROM property WHERE pro_type=1
  ),--购买了理财产品的客户与理财产品表
  T2 AS(
        SELECT property.pro_c_id pac,T1.pro_c_id pbc,property.pro_pif_id FROM property,T1 WHERE pro_type=1 AND property.pro_pif_id=T1.pro_pif_id AND property.pro_c_id!=T1.pro_c_id
  ),--购买了相同的理财产品的用户和所购买的相同的理财产品表
  T3 AS(
         SELECT pac,pbc,COUNT(*) common,RANK()OVER(PARTITION BY pac ORDER BY common DESC,pbc) AS crank FROM T2 GROUP BY pac,pbc
  )--购买了相同理财产品的用户以及购买的相同产品数和排名
  SELECT pac,pbc,common,crank FROM T3 WHERE crank<=2 ORDER BY pac,crank;
  ;--找到相似度前两名的客户对
  --/*  end  of  your code  */
  ```
  
  

## 数据的插入、修改与删除 

- 第1关

  向客户表插入以下3条数据

  ```
  -- 用insert语句向客户表(client)插入任务要求的3条数据:
  INSERT INTO  client (c_id,c_name,c_mail,c_id_card,c_phone,c_password) VALUES
  (1,'林惠雯','960323053@qq.com','411014196712130323','15609032348','Mop5UPkl'),
  (2,'吴婉瑜','1613230826@gmail.com','420152196802131323','17605132307','QUTPhxgVNlXtMxN'),
  (3,'蔡贞仪','252323341@foxmail.com','160347199005222323','17763232321','Bwe3gyhEErJ7');
  /* end of you code */
  ```

- 第2关

  向客户表client插入一条数据不全的记录。

  ```
  -- 已知33号客户部分信息如下:
  -- c_id(编号):33
  -- c_name(名称):蔡依婷
  -- c_phone(电话):18820762130
  -- c_id_card(身份证号):350972199204227621
  -- c_password(密码):MKwEuc1sc6
  
  -- 请用一条SQL语句将这名客户的信息插入到客户表(client)：
  
  
  INSERT INTO  client (c_id,c_name,c_id_card,c_phone,c_password) VALUES
  (33,'蔡依婷','350972199204227621','18820762130','MKwEuc1sc6');
  /* the end of your code */ 
  ```

- 第3关

  向客户表client批量插入数据

  已知表new_client保存了一批新客户信息，该表与client表结构完全相同。请用一条SQL语句将new_client表的全部客户信息插入到客户表(client)。

  ```
  -- 已知表new_client保存了一批新客户信息，该表与client表结构完全相同。请用一条SQL语句将new_client表的全部客户信息插入到客户表(client):
  -- c_id | c_name |             c_mail             |     c_id_card      |   c_phone
  
  INSERT INTO  client 
  SELECT * FROM new_client;
  
  /* the end of your code */
  ```

- 第4关

  请用一条SQL语句删除client表中没有银行卡的客户信息。

  ```
  -- 请用一条SQL语句删除client表中没有银行卡的客户信息：
  DELETE FROM client WHERE NOT EXISTS(
      SELECT b_number FROM bank_card WHERE b_c_id=c_id
  );
  /* the end of your code */ 
  ```

- 第5关

  请用一条update语句将手机号码为“13686431238”这位客户的投资资产(理财、保险与基金)的状态置为“冻结”。

  ```
  -- 请用一条update语句将手机号码为“13686431238”的这位客户的投资资产(理财、保险与基金)的状态置为“冻结”。：
  UPDATE property SET pro_status='冻结' WHERE EXISTS(
      SELECT c_id FROM client WHERE c_phone='13686431238'AND c_id=property.pro_c_id
  );
  /* the end of your code */
  ```

- 第6关

  请用一条update语句，根据client表中提供的身份证号(c_id_card)，填写property表中对应的身份证号信息(pro_id_card)。

  ```
  -- 在金融应用场景数据库中，已在表property(资产表)中添加了客户身份证列，列名为pro_id_card，类型为char(18)，该列目前全部留空(null)。
  -- 请用一条update语句，根据client表中提供的身份证号(c_id_card)，填写property表中对应的身份证号信息(pro_id_card)。
  UPDATE property SET pro_id_card=(
      SELECT c_id_card FROM client WHERE c_id=pro_c_id
  );
  /* the end of your code */
  ```

## 视图

- **VIEW**

  **View（视图）是一张假表，只不过是通过相关的名称存储在数据库中的一个 PostgreSQL 语句。**

  **View（视图）实际上是一个以预定义的 PostgreSQL 查询形式存在的表的组合。**

  **View（视图）可以包含一个表的所有行或从一个或多个表选定行。**

  **View（视图）可以从一个或多个表创建，这取决于要创建视图的 PostgreSQL 查询。**

  **View（视图）是一种虚拟表，允许用户实现以下几点：**

  - **用户或用户组认为更自然或直观查找结构数据的方式。**
  - **限制数据访问，用户只能看到有限的数据，而不是完整的表。**
  - **汇总各种表中的数据，用于生成报告。**

  **PostgreSQL 视图是只读的，因此可能无法在视图上执行 DELETE、INSERT 或 UPDATE 语句。但是可以在视图上创建一个触发器，当尝试 DELETE、INSERT 或 UPDATE 视图时触发，需要做的动作在触发器内容中定义。**

- 第1关

  填写1条SQL语句，完成以下任务： 创建包含所有保险资产记录的详细信息的视图v_insurance_detail，包括购买客户的名称、客户的身份证号、保险名称、保障项目、商品状态、商品数量、保险金额、保险年限、商品收益和购买时间。

  ```
  -- 创建包含所有保险资产记录的详细信息的视图v_insurance_detail，包括购买客户的名称、客户的身份证号、保险名称、保障项目、商品状态、商品数量、保险金额、保险年限、商品收益和购买时间。
  -- 请用1条SQL语句完成上述任务：
  CREATE VIEW v_insurance_detail AS
  SELECT c_name,c_id_card,i_name,i_project,pro_status,pro_quantity,i_amount,i_year,pro_income,pro_purchase_time FROM client,property,insurance WHERE pro_type=2 AND pro_c_id=c_id AND pro_pif_id=i_id;
  /*   end  of your code  */
  ```

- 第2关

  基于上一关创建的视图v_insurance_detail进行分组统计查询，列出每位客户的姓名，身份证号，保险投资总额(insurance_total_amount)和保险投资总收益(insurance_total_revenue),结果依保险投资总额降序排列。

  ```
   -- 基于上一关创建的视图v_insurance_detail进行分组统计查询，列出每位客户的姓名，身份证号，保险投资总额(insurance_total_amount)和保险投资总收益(insurance_total_revenue),结果依保险投资总额降序排列。
  --  请用一条SQL语句实现该查询：
  SELECT c_name,c_id_card,SUM(pro_quantity*i_amount) insurance_total_amount,SUM(pro_income) insurance_total_revenue FROM v_insurance_detail GROUP BY c_name,c_id_card ORDER BY insurance_total_amount DESC;
  /*  end  of  your code  */
  ```

## 存储过程与事务

- 第1关

  任务：创建一个存储过程，向表fibonacci插入斐波拉契数列的前n项。

  知识点：

  - 变量定义与赋值

    用declare语句定义变量，并赋予默认值或初始值，未赋默认值 则初始值为null:

     `DECLARE var_name [, var_name] ... type [DEFAULT value]` 

    在OpenGauss中，变量赋值语句如下：

     `variable := expr [, variable = expr]`

    还可以通过select语句给变量赋值：

     `select col into var_name from table; #将table表中的col列值赋给变量`

  - 复合语句

    1.复合语句BEGIN...END

    ```
    BEGIN[statement_list]END 
    ```

    2.if语句

    ```
    IF search_condition THEN  statement_list[ELSEIF search_condition THEN statement_list] ...[ELSE statement_list]END IF 
    ```

    3.while语句

    ```
    WHILE search_condition LOOP   statement_listEND LOOP
    ```

  - 存储过程定义

    **存储过程**（`Stored Procedure`）是一种在数据库中存储复杂程序，以便外部程序调用的一种数据库对象。

    存储过程是为了完成特定功能的 `SQL` 语句集，经编译创建并保存在数据库中，用户可通过指定存储过程的名字并给定参数（需要时）来调用执行。

    存储过程思想上很简单，就是数据库 `SQL` 语言层面的代码**封装与重用**。

    简单的说存储过程就是具有名字的一段代码，用来完成一个特定的功能。

  - 存储过程的创建和查询

    创建存储过程：`create procedure 存储过程名(参数) `

    - 下面我们来创建第一个存储过程

    每个存储的程序都包含一个由 `SQL` 语句组成的主体。此语句可能是由以分号（`;`）字符分隔的多个语句组成的复合语句。例如：

    ```
    CREATE PROCEDURE proc1()as
    BEGIN
    insert into test values(1);
    END;
    \
    ```

    在命令行客户端中，如果有一行命令以分号结束，那么回车后，`OpenGauss` 将会执行该命令，但在创建存储过程中我们并不希望 `OpenGauss` 这么做。于是使用（create procedure proc_name as） 开头，以符号（\）结尾。中间的（;）就会忽略。

    - 执行存储过程：`call 存储过程名`
    - 创建带有参数的存储过程 存储过程的参数有三种：
      - `IN`：输入参数，也是默认模式，表示该参数的值必须在调用存储过程时指定，在存储过程中修改该参数的值不能被返回；
      - `OUT`：输出参数，该值可在存储过程内部被改变，并可返回；
      - `IN OUT`：输入输出参数，调用时指定，并且可被改变和返回。

  ```
  -- 创建存储过程`sp_fibonacci(in m int)`，向表fibonacci插入斐波拉契数列的前m项，及其对应的斐波拉契数。fibonacci表初始值为一张空表。请保证你的存储过程可以多次运行而不出错。
  
  create procedure sp_fibonacci(in m int)
  as
  declare i int default 0;--用来计数几个值
  declare f0 bigint default 0;--要插入的当前值
  declare f1 bigint default 1;--要插入的下一个值
  declare f2 bigint default 1; --要插入的下下一个值
  begin
  -- ######## 请补充代码完成存储过程体 ########
  
  while i<m loop
      insert into fibonacci values(i,f0);
      i:=i+1;
      f0:=f1;
      f1:=f2;
      f2:=f0+f1;
  end loop;
  
  end;
  /
  ```

- 第2关

  **知识点：**

  ##### 游标的特点

  SQL操作都是面向集合的，即操作的对象以及运算的结果均为集合，但有时候，我们需要一行一行地处理数据，这就需要用到游标(CURSOR)，它相当于一个存储于内存的带有指针的表，每次可以存取指针指向的一行数据，并将指针向前推进一行。游标的数据通常是一条查询语句的结果。对游标的操作一般要用循环语句，遍历游标的每一行数据，并将该行数据读至变量，再根据变量的值进行所需要的其它操作。

  游标有以下持点：

  - 不可滚动。即只能从前往后遍历游标数据(即从第1行到最后一行)，不能反向遍历，不能跳跃遍历，不能直接访问中间的某一行。
  - 只读。游标里的数据只能读取，不能修改。

  ##### 游标的定义与使用

  创建并使用OpenGauss游标，至少会用到声明游标, OPEN, FETCH, 和CLOSE语句。

  **1.声明游标语句** 用DECLARE语句变量以及特情处理程序，用CURSOR语句定义游标。在一个BEGIN...END语句块内，DECLARE定义的顺序要求如下：

  1. 变量
  2. 游标
  3. 特情处理

  即变量定义在游标之前，特情处理程序定义在游标之后。 变量用来存储从游标读取的数据，根据编程逻辑的需，可能还要定义其它变量；游标用来存储SELECT语句读取的数据集；当某些特定情形出现时，会自动触发对应的特情处理程序。在游标的使用中，你至少需要定义当遍历至游标数据结束(抛出NOT FOUND异常)时该怎么办(当然是结束循环)。

  定义变量： `DECLARE var_name [, var_name] ... type [DEFAULT value]`

  定义游标： `CURSOR cursor_name  FOR select_statement` 任何合法的select语句(不能带INTO短语)，都可以定义成游标。此后可用FETCH语句读取这个select语句查询到的数据集中的一行数据。

  注意游标必须定义在变量之后，特情处理程序之前。 一个存储过程可义定义多个游标，但不能同名。

  特情处理：

  游标应用中需要注意FETCH语句结束的情况： `LOOP`  `FETCH C1 INTO TEMP;`  `EXIT WHEN C1%NOTFOUND;` `END LOOP;` 其含义是将C1游标的值付给变量TEMP，当游标C1有值时C1%NOTFOUND置0，取不到值时C1%NOTFOUND置1，语句EXIT WHEN C1%NOTFOUND表示当C1%NOTFOUND为1时退出循环。

  当一个存储过程中存在多个游标时，对任何一个游标的读取(FETCH)都可能会触发特情处理。比如一个游标的数据被遍历完毕，再试图FETCH下一行时，会触发NOT FOUND HANDLER, 并进而改变某个变量的值，但另一个游标中可能还有未处理完的数据。编程者应当自己想办法区分是哪个游标的数据处理完毕。 

  **2. OPEN语句** `OPEN cursor_name` 该语句打开之前定义的游标，并初始化指向数据行的指针(接下来的第一条FETCH语句将试图读取游标的第1行数据)。

  **3.FETCH语句** `FETCH [[NEXT] FROM] cursor_name INTO var_name [, var_name] ...` FETCH语句读取游标的一行数据到变量列表,并推进游标的指针.关键词NEXT, FROM都可省略(或仅省略NEXT)。注意INTO后的变量列表应当与游标定义中的SELECT列表一一对应(变量个数与SELECT列表个数完全相同，数据类型完全一致，每个变量的取值按SELECT列表顺序一一对应)。

  FETCH一个未打开的游标会出错。

  **4. CLOSE语句** `CLOSE cursor_name` Close语句关闭先前打开的游标，试图关闭一个未曾打开(OPEN)的游标会出错。

  没有CLOSE的游标，在其定义的BEGIN...END语句块结束时，将自动CLOSE。

  任务：

  ```
  -- 编写一存储过程，自动安排某个连续期间的大夜班的值班表:
  create procedure sp_night_shift_arrange(in start_date date, in end_date date)
  AS
  CURSOR doctor FOR
  select e_name from employee where e_type=1 or e_type=2 order by e_id;
  CURSOR nurse FOR
  select e_name from employee where e_type=3 order by e_id;
  declare cur_date date;
  declare doctor_name char(30);
  declare nurse_name1 char(30);
  declare nurse_name2 char(30);
  declare doctor_type int;
  declare flag int default 0;
  declare zhou int;
  declare zhuren char(30);
  
  begin
      open doctor;
      open nurse;
      cur_date:=start_date;
      select e_name into zhuren from employee where e_type=1;
      while cur_date<=end_date loop
          zhou:=extract(dow from cur_date);--这一天是周几
          if zhou=0 or zhou=6 then--周六和周日判断当前是否是主任
              fetch doctor into doctor_name;--先找到这个人
              if doctor%notfound then --doctor已经遍历完了，就重头开始
                  close doctor;
                  open doctor;
                  fetch doctor into doctor_name;
              end if;
              if doctor_name=zhuren then --如果是主任
                  flag:=1;
                  fetch doctor into doctor_name;--再找一个医生
                  if doctor%notfound then --doctor已经遍历完了，就重头开始
                      close doctor;
                      open doctor;
                      fetch doctor into doctor_name;
                  end if;
              end if;
          elseif zhou=1 then--如果是周一
              if flag=1 then 
                  doctor_name=zhuren;--之前主任轮空，轮到主任
                  flag=0;
              else 
                  fetch doctor into doctor_name;--之前主任没有轮空
                  if doctor%notfound then --doctor已经遍历完了，就重头开始
                      close doctor;
                      open doctor;
                      fetch doctor into doctor_name;
                  end if;
              end if;
          else
              fetch doctor into doctor_name;--普通情况找一个医生
              if doctor%notfound then --doctor已经遍历完了，就重头开始
                  close doctor;
                  open doctor;
                  fetch doctor into doctor_name;
              end if;
          end if;
          fetch nurse into nurse_name1;
          if nurse%notfound then--找护士1
              close nurse;
              open nurse;
              fetch nurse into nurse_name1;
          end if;
          fetch nurse into nurse_name2;
          if nurse%notfound then
              close nurse;
              open nurse;
              fetch nurse into nurse_name2;
          end if;
          insert into night_shift_schedule values(cur_date,doctor_name,nurse_name1,nurse_name2);
          cur_date:=cur_date::date+interval'1 D';
      end loop;
      close doctor;
      close nurse;
  end;
  /*  end  of  your code  */ 
  
  
  值得注意的是下面的这种写法是不对的，游标到了结尾再fetch一下才能notfound
          if nurse%notfound then--找护士
              close nurse;
              open nurse;
          else
              fetch nurse into nurse_name1;
          end if;
          if nurse%notfound then
              close nurse;
              open nurse;
          else
              fetch nurse into nurse_name2;
          end if;
          insert into employee values(cur_date,zhou,doctor_name,nurse_name1,nurse_name2);
          cur_date:=cur_date::date+interval'1 D';
  
  
  ```

- 第3关

  知识点：

  ##### **事务的定义和应用**

  开启事务： • 在OpenGauss中，存储过程本身就处于一个事务中，开始调用最外围存储过程时会自动开启一个事务，在调用结束时自动提交或者发生异常时回滚。除了系统自动的事务控制外，也可以使用COMMIT/ROLLBACK来控制存储过程中的事务。在存储过程中调用COMMIT/ROLLBACK命令，将提交/回滚当前事务并自动开启一个新的事，后续的所有操作都会在此新事务中运行。所以在存储过程中不要使用start transaction开启事务。 事务提交： • COMMIT  事务回滚： • ROLLBACK

  任务：

  - 仅当转款人是转出卡的持有人时，才可转出；
  - 仅当收款人是收款卡的持有人时，才可转入；
  - 储蓄卡之间可以相互转账；
  - 允许储蓄卡向信用卡转账，称为信用卡还款(允许替它人还款)，还款可以超过信用卡余额，此时，信用卡余额为负数；
  - 信用卡不能向储蓄卡转账；
  - 转账金额不能超过储蓄卡余额；

  ```
  -- 在金融应用场景数据库中，编程实现一个转账操作的存储过程sp_transfer_balance，实现从一个帐户向另一个帐户转账。
  -- 请补充代码完成该过程：
  create procedure sp_transfer(IN applicant_id int,      
                       IN source_card_id char(30),
  					 IN receiver_id int, 
                       IN dest_card_id char(30),
  					 IN	amount numeric(10,2),
  					 OUT return_code int)
  as 
  declare a_type char(20);
  declare r_type char(20);
  declare balance NUMERIC(10,2);
  
  begin	
  	--仅当转款人是转出卡的持有人时，才可转出；
      if not exists (select b_c_id from bank_card where b_c_id=applicant_id and b_number=source_card_id) 
      then return_code:=0;return;
      end if;
  	--仅当收款人是收款卡的持有人时，才可转入；
      if not exists (select b_c_id from bank_card where b_c_id=receiver_id AND b_number=dest_card_id) 
      then return_code:=0;return 0;
      end if;
      select b_type into a_type from bank_card where b_number=source_card_id;--付款人的卡类型
      select b_type into r_type from bank_card where b_number=dest_card_id;--收款人卡类型
  	--信用卡不能向储蓄卡转账；
      if a_type='信用卡' and r_type='储蓄卡' 
      then return_code:=0;return 0;
      end if;
      select b_balance into balance from bank_card where b_number=source_card_id;
  	--转账金额不能超过储蓄卡余额；
      if balance<amount 
      then return_code:=0;return 0;
      end if;
      update bank_card set b_balance=b_balance-amount where b_number=source_card_id;
      if r_type='信用卡' then update bank_card set b_balance=b_balance-amount where b_number=dest_card_id;
      else update bank_card set b_balance=b_balance+amount where b_number=dest_card_id;
      end if;
      commit;
      return_code:=1;return 1;
  end; 
  /*  end  of  your code  */ 
  ```

## 触发器

#### 触发器

触发器是与某个表绑定的命名存储对象，与存储过程一样，它由一组语句组成，当这个表上发生某个操作(insert,delete,update)时，触发器被触发执行。触发器一般用于实现业务完整性规则。当primary key,foreigh key, check等约束都无法实现某个复杂的业务规则时，可以考虑用触发器来实现。

#### 触发器的创建

创建触发器的语句： `CREATE  TRIGGER trigger_name { BEFORE | AFTER | INSTEAD OF } { event [ OR ... ] }` `ON table_name` `[ FROM referenced_table_name ]` `{ NOT DEFERRABLE | [ DEFERRABLE ] { INITIALLY IMMEDIATE | INITIALLY DEFERRED } }` `[ FOR [ EACH ] { ROW | STATEMENT } ] [ WHEN ( condition ) ]` `EXECUTE PROCEDURE function_name ( arguments );`

- trigger_nme: 每个触发器有一个唯一的命名
- trigger_time: 触发的时机，二选一： BEFORE | AFTER  
- trigger_event: 触发事件，四选一： INSERT | UPDATE | DELETE |TRUNCATE
- tbl_name: 与触发器绑定的表
- function_name: 触发器体由函数定义。但是必须声明为不带参数并返回类型为触发器。具体函数声明的方法参考OpenGauss函数实训。

与创建存储过程、函数一样，创建触发器时也要用delimiter语句重新指定触发器定义语句的界符(触发器内语句的分隔符仍为分号)，在触发器定义之后，再把界符更改回去。

**before与after触发器的区别:**

- before触发器在试图激活触发器的那条语句(insert|delete|update|truncate)之前执行。
- after触发器仅在before触发器(如果有的话)和试图激活触发器的那条语句都成功执行后才执行。
- before触发器或after触发器如果未能成功执行，则激活触发器的语句也不会执行。

#### 触发器内的特殊变量

在触发器内可以使用两类特殊变量：

- OLD.  UPDATE及DELETE操作涉及tuple信息 中的旧值，对INSERT为空。
- NEW. INSERT及UPDATE操作涉及tuple信息 中的新值，对DELETE为空。
- 其它特殊变量.参考OpenGauss手册。



**任务：**

为表property(资产表)编写一个触发器，以实现以下完整性业务规则：

- 如果pro_type = 1, 则pro_pif_id只能引用finances_product表的p_id；
- 如果pro_type = 2, 则pro_pif_id只能引用insurance表的i_id；
- 如果pro_type = 3, 则pro_pif_id只能引用fund表的f_id；
- pro_type不接受(1,2,3)以外的值。

各投资品种一经销售，不会再改变；

```
--创建触发器函数TRI_INSERT_FUNC()
CREATE OR REPLACE FUNCTION TRI_INSERT_FUNC() RETURNS TRIGGER AS
$$
DECLARE
   --此处用declare语句声明你所需要的变量
BEGIN
   --此处插入触发器业务
   --如果pro_type = 1, 则pro_pif_id只能引用finances_product表的p_id；
   if new.pro_type=1
   then 
   if not exists(select * from finances_product where new.pro_pif_id=p_id)
   then raise exception '%',concat('finances product #',to_char(new.pro_pif_id),' not found!');
   end if;
   --如果pro_type = 2, 则pro_pif_id只能引用insurance表的i_id；
   elseif new.pro_type=2
   then
      if not exists(select * from insurance where new.pro_pif_id=i_id)
         then raise exception '%',concat('insurance #',to_char(new.pro_pif_id),' not found!');
   end if;
   --如果pro_type = 3, 则pro_pif_id只能引用fund表的f_id；
   elseif new.pro_type=3
   then
      if not exists(select * from fund where new.pro_pif_id=f_id)
         then raise exception '%',concat('fund #',to_char(new.pro_pif_id),' not found!');
   end if;
   --pro_type不接受(1,2,3)以外的值。
   else
      raise exception '%',concat('type',' ',to_char(new.pro_type),' ','is illegal!');
   end if;
   --触发器业务结束
   return new;--返回插入的新元组
END;
$$ LANGUAGE PLPGSQL;

-- 创建before_property_inserted触发器，使用函数TRI_INSERT_FUNC实现触发器逻辑：
CREATE  TRIGGER before_property_inserted BEFORE INSERT ON property
FOR EACH ROW 
EXECUTE PROCEDURE TRI_INSERT_FUNC();
```

## 用户自定义函数

### 函数定义和应用

函数其实有多种，比如标量函数(仅返回一个值)和表函数(返回结果是表),语法也各不相同。这里，我们仅给出一个简化的创建标量函数的语法:

create function语句的语法：

create function function_name([para data_type[,...]]) returns data_type begin    function_body;    return expression;  end

- function_name:函数名；
- para:参数名；
- data_type:参数的数据类型；
- 一个函数可以没有参数，也可以有多个。多参数间用逗号分隔。
- function_body:函数体。即由合法的SQL语句组成的程序段。
- expression:函数返回值，可以是常量、表达式，甚至是一条select语句查询的值（必须保证结果唯一);该值类型应与returns短语定义的类型相同。

函数一旦定义，就可以像内部函数一样使用，比如出现在select列表、表达式、以及where子句的条件中。



任务：

(1) 用create function语句创建符合以下要求的函数：

- 依据客户编号计算其所有储蓄卡余额的总和。
- 函数名为：get_deposit

(2) 利用创建的函数，仅用一条SQL语句查询存款总额在100万(含)以上的客户身份证号，姓名和存款总额(total_deposit)，结果依存储总额从高到低排序。

```

/*
   用create function语句创建符合以下要求的函数：
   依据客户编号计算该客户所有储蓄卡的存款总额。
   函数名为：get_Records。函数的参数名可以自己命名:*/

CREATE OR REPLACE FUNCTION get_deposit(client_id integer) 
 returns numeric(10,2)
 LANGUAGE plpgsql
AS
$$
--声明变量的地方
declare num numeric(10,2);
--函数体
begin
   num:=(select sum(b_balance) from bank_card where b_type='储蓄卡' and b_c_id=client_id group by b_c_id);
   return num;
end;
$$;

/*  应用该函数查询存款总额在100万(含)以上的客户身份证号，姓名和存储总额(total_deposit)，
    结果依存款总额从高到代排序  */
    select c_id_card,c_name,total_deposit from(
        select c_id_card,c_name,get_deposit(c_id) as total_deposit
        from client
        order by total_deposit desc
    ) where total_deposit id not null and total_deposit>=1000000;

/*  代码文件结束     */
/*  代码文件结束     */
```

## 安全性控制

- 第1关

  知识点：

  #### OpenGauss的安全控制机制

  与大多数商用DBMS一样，OpenGauss采用自主存取控制(DAC)机制进行安全性管理。通过用户，数据对象，权限，授权，收回权限等要素进行存取控制。另外，为了方便批量授权给同一类用户，引入了角色。

  #### 用户(User)

  OpenGauss创建用户的语句： `create user 用户名 with password 用户登录密码；` 通常用户名可包含域名，限定用户在该域名内登录再有效。例： `CREATE USER 'jeffrey'@'localhost' IDENTIFIED BY 'password_1234';` 该语句创建用户jeffrey,密码为'password'，仅限在OpenGauss服务器本机上登录才有效。用户名与域合起来，被称为账户(account)。 注意不要写成：'jeffrey@localhost'，它代表账户： 'jeffrey@localhost'@'%' 意即用户名为jefrrey@localhost，在任何机器上登录都有效。两者的含义完全不同。 省略域名，即默认为'%',表示用户可远程登录。在本实训中，可以省略域，这时，用户名可以不加引号。

  drop user语句可删除用户。用户被删除时，该用户拥有的权限自动被收回。 alter user语句可重置用户密码： `ALTER USER user IDENTIFIED BY 'new_password';`

  OpenGauss在安装时，初始用户名为root，此为系统管理员用户，其余用户均由root创建，并授权。经授权的用户也可以创建用户。

  在生产环境中，除了管理员，其它人应当使用由管理员创建的账户，不得使用root帐户。出于安全考虑，一般root用户也仅限在服务器本地登录，不轻易开放远程登录。

  #### 权限

  OpenGauss常用的权限有：

  - all: 所有权限(grant option除外)
  - alter: alter table权限 
  - alter routine: alter 存储过程
  - create: create database/table
  - create role: create role
  - create foutine: create 存储过程和函数
  - create user： create/alter/rename/drop user
  - create view: create view
  - delete: delete语句
  - drop: drop database/table
  - drop role: drop role
  - execute: 调用存储过程或函数
  - index：create/drop index
  - insert: insert语句
  - select: select语句
  - trigger: 触发器相关操作
  - update: update语句 等。 select,update,insert,delete还可以用在列上，如select(c_id),update(b_balance)等。

  #### 角色(Role)

  角色是权限的集合。如果有一组人(承担相同职责的小组,或者説小组成员扮演相同的角色)应该被授予一组相同的权限，不妨创建一个角色，将那组权限授予该角色，然后再将角色授予该组的每个成员。这比一个个地给每个组员授予一批权限要方便得多。

  创建角色的语句： `CREATE ROLE [IF NOT EXISTS] role [, role ] ...` 一次可以创建多个角色。 删除角色： `DROP ROLE [IF EXISTS] role [, role ] ...` 角色被删除后，拥有该角色的用户立即失去角色定义的权限组合。不过，如果用户同时拥有多个角色，两个角色代表的权限集合如果有交集，则该用户仍拥有交集代表的权限。

  #### GRANT授权语句

  以下语句授予权限给用户或角色： `grant 权限[,权限] ... on 数据库对象 to user|role,[user|role]... [with grant option]` 可以同时将多个权限授予多个用户或角色。 with grant option表示被授权用户可以传播权限，即授权该用户将其拥有的权限（之前获得的权限，通过本语句获得的权限，以及今后获得的权限）再授予其它用户。

  以下语句授予角色所代表的权限集给用户或角色： `GRANT role [, role] ... TO user_or_role [, user_or_role] ... [WITH ADMIN OPTION]`

  总之，GRANT语句可以将权限或角色（权限集合）授予用户或角色。但是不能将权限和角色混合授予用户(或角色)。不过，你可以分开用两条不同的GRANT语句来实现：直接授权语句有关键词ON，间接授权(角色代表的权限集合)语句不带ON关键词。

  #### REVOKE收回权限语句

  以下语句将对象的权限从用户或角色手中收回： `revoke 权限[,权限]... on 数据库对象 from user|role[,user|role]... `

  下列语句把role所代表的权限集合从用户或角色中收回： `REVOKE role [, role ] ... FROM user_or_role [, user_or_role ] ...` 如果用户本身拥有多个角色所代表的权限集合，而这些集合存在交集，收回其中部分角色代表的权限集后，用户可能仍拥有那个角色所代表的部分权限(交集代表的那部分权限)。

  

  任务：

  (1) 创建用户tom和jerry，初始密码均为'hust_1234'； 

  (2) 授予用户tom查询客户的姓名，邮箱和电话的权限,且tom可转授权限；

  (3) 授予用户jerry修改银行卡余额的权限；

   (4) 收回用户Cindy查询银行卡信息的权限。

  ```
  -- 请填写语句，完成以下功能：
  --(1) 创建用户tom和jerry，初始密码均为；
  CREATE USER tom WITH PASSWORD 'hust_1234';
  CREATE USER jerry IDENTIFIED BY 'hust_1234';
  --(2) 授予用户tom查询客户的姓名，邮箱和电话的权限,且tom可转授权限；
  grant select(c_phone,c_name,c_mail)  on client to tom with grant option;
  --(3) 授予用户jerry修改银行卡余额的权限；
  grant update(b_balance)  on bank_card to jerry;
  --(4) 收回用户Cindy查询银行卡信息的权限。
  revoke select on bank_card from cindy;

- 第2关

  (1) 创建角色client_manager和fund_manager；

   (2) 授予client_manager对client表拥有select,insert,update的权限； 

  (3) 授予client_manager对bank_card表拥有查询除银行卡余额外的select权限；

   (4) 授预fund_manager对fund表的select,insert,update权限；

  (5) 将client_manager的权限授予用户tom和jerry；

  (6) 将fund_manager权限授予用户Cindy.

  ```
  -- 请填写语句，完成以下功能：
  -- (1) 创建角色client_manager和fund_manager；
  create role client_manager with password 'hust_1234';
  create role fund_manager with password 'hust_1234';
  -- (2) 授予client_manager对client表拥有select,insert,update的权限；
  grant select,insert,update on client to client_manager;
  -- (3) 授予client_manager对bank_card表拥有查询除银行卡余额外的select权限；
  grant select(b_number,b_type,b_c_id) on bank_card to client_manager;
  -- (4) 授预fund_manager对fund表的select,insert,update权限；
  grant select,insert,update on fund to fund_manager;
  -- (5) 将client_manager的权限授予用户tom和jerry；
  grant client_manager to tom,jerry;
  -- (6) 将fund_manager权限授予用户Cindy.
  grant fund_manager to cindy;

## 并发控制与事务的隔离级别

- 第1关：不可重复读

  #### 相关知识

  并发操作可能产生的数据不一致性； OpenGauss的事务隔离级别； 隔离级别，一致性和并发度的关系。

  ##### 并发操作可能产生的数据不一致性

  数据库是共享资源，允许多个用户同时访问同一数据库，特别是在互联网应用成为主流的当下，高可用性、高并发是所有应用追求的目标。但并发操作不加控制，便会产生数据的不一致性。 并发操作可能带来的数据不一致性包括：

  - 丢失修改(lost update)
  - 脏读：一个事务读取了另一个并行未提交事务写入的数据。
  - 不可重复读：一个事务重新读取之前读取过的数据，发现该数据已经被另一个事务（在初始读之后提交）修改。
  - 幻读：一个事务重新执行一个返回符合一个搜索条件的行集合的查询， 发现满足条件的行集合因为另一个最近提交的事务而发生了改变。
  - 序列化：禁止所有并发异象，效果如同事务以串行的方式执行。

  为解决上述不一致性问题,DBMS设计了专门的并发控制子系统，采用封锁机制进行并发控制，以保证事务的隔离性和一致性(事务是并发控制的基本单位)。

  但事务的隔离程度越高，固然一致性--或者説数据的正确性越有保障，但并发度就会越低。很多时候，需要在一致性和并发度间进行取舍，从而就生产了事务的隔离级别的概念。 隔离级别越高，一致性程度越高，并发度越低。反之，隔离级别越低，并发度越高，但代价是会出现某些数据不一致现象。

  ##### OpenGauss的事务隔离级别

  在前述的几类不一致性中，只有丢失修改是不能容忍的，所有的商用DBMS，其事务管理和并发控制子系统都不会允许这种情形发生。所以，事务隔离级别的最低限度是容忍“读脏”。在追求高并发的场景中，除“丢失修改”外，其它不一致性都是可以容忍的。

  不同的DBMS，其事务的隔离级别划分是不同的。 OpenGauss的事务隔离级别从低到高分以下三级：

  - 读已提交（READ COMMITTED）
  - 可重复读（REPEATABLE READ）
  - 可串行化（SERIALIZABLE）
  
  **1、Read uncommitted**
  
  读未提交，指的就是一个事务可以读取另一个未提交事务的数据。
  
  打个比方：你打算在网上买一台新的电脑，看到一家店中原价6000的电脑，现价只要998，没错，只要998。但是当你开开心心去付款的时候，价格又变成了6000，为啥呢？原来店家老板在输入商品单价的时候(事务开始)，不小心按错写成998了，但是事务还没有提交，这时被你看见了，可老板及时发现了不对，马上回滚差点就提交了的事务，将数字改成6000再提交。
  
  小结：商品价格还是原先的6000，但是你却看到了998。这是老板输错了还没提交的数据，这就是脏读。
  
  那怎么解决脏读呢？Read committed！读提交，能解决脏读问题。
  
  **2、Read committed**
  
  读提交，就是指一个事务要等另一个事务提交后才能读取数据。
  
  打个比方：尽管你发现这台电脑不是998，而是6000，因为你很喜欢，所以咬咬牙还是决定用卡里最后的6000块买下这台电脑。当你开始支付订单时(事务开始)，收费系统事先检测到你的卡里有6000块。但是当收费系统准备扣款时，再检测卡里的金额，发现钱不够了。你还在纳闷为啥的时候，你收到一条短信：恭喜您成功续费xxx视频的会员！原来你之前购买的xxx视频的会员在这个时候自动续费了，扣掉了20块，导致你没钱买电脑了(第二次检测金额就是等待会员续费转出金额事务提交完）。
  
  说明：这就是读提交，若有事务对数据进行更新（UPDATE）操作时，读操作事务要等待这个更新操作事务提交后才能读取数据，可以解决脏读问题。但在这个事例中，出现了一个事务范围内两个相同的查询却返回了不同数据，这就是不可重复读。
  
  **3、Repeatable read**
  
  重复读，就是在开始读取数据（事务开启）时，不再允许修改操作。
  
  举例：你终于等到发工资了，这时你卡里有钱去买电脑了。当你支付订单时(事务开启，不允许其他事务的UPDATE修改操作)，收费系统检测到你卡里有6000块，现在不允许其它事务从你的卡里扣钱了，你终于如愿买到新电脑了。
  
  说明：利用重复读终于可以解决不可重复读问题了。但是要注意的是：不可重复读对应的是修改，即UPDATE操作。但是可能还会有幻读问题。因为幻读问题对应的是插入INSERT操作，而不是UPDATE操作。
  
  **4、幻读**
  
  买完电脑之后，你想看看今天的账单，看看卡里还是多少钱。看到确实是花了6000元，还剩1000块，就在这个时候，你的视频会员又给你自动续费了，即新增INSERT了一条消费记录，并提交。当你打印出自己的账单时，发现卡里980了，怎么少了20块，似乎出现了幻觉，这就是幻读
  
  **5、序列化**
  
  Serializable 是最高的事务隔离级别，在该级别下，事务串行化顺序执行，可以避免脏读、不可重复读与幻读。但是这种事务隔离级别效率低下，比较耗数据库性能，一般不使用。

**查询事务的隔离级别** 可用以下语句查询OpenGauss的事务隔离级别： `show transaction_isolation;;` 缺省值均为：READ COMMITTED，即读已提交。

**设置事务的隔离级别** 以下语句设置事务的隔离级别为可读未提交(read uncommitted): `set session transaction isolation level read committed;` 如需设置为其它级别，只需替换最后的隔离级别即可。 不同的事务隔离级别意味着不同的封锁协议，程序员只需设置事务的隔离级别即可，其它的交给DBMS并发子系统处理。 不过，OpenGauss支持在select语句中使用for share或for update短语主动申请S锁或X锁(只到事务结束才释放)。这样，即使在隔离级别为read committed的情形下，仍有机会保证可重复读。

  ##### 不可重复读

  	不可重复读(unrepeatable read)，是指一个事务(t1)读取到某数据后，另一个事务(t2)修改了该，事务t1并未修改该数据，但当t1再次读取该数据时，发现两次读取的结果不一样。

  ##### 产生不可重复读的原因

 	 显然，不可重复读产生的原因，是事务t1的两次读取之间，有另一个事务修改了t1读取的数据。



任务：

现有两个涉及该表的并发事务t1和t2，分别定义在t1.sql和t2.sql代码文件中,请在两个代码文件适当的地方补充代码，构造“不可重复读”现象。t2是发生不可重复读的那个事务,t1在t2的两次连续读之间修改了数据

分析

| 时刻 | 事务1   | 事务2     |
| ---- | ------- | --------- |
| 1    | 读票(0) | 等待      |
| 2    | 等待    | 读票(0.5) |
| 3    | 修改(1) | 等待      |
| 4    | 等待    | 读票(1.5) |
| 5    | 等待    | 修改(2)   |
| 6    | 读票(3) | 等待      |

代码为：

  ```
-- 事务1:
-- 请设置适当的事务隔离级别
set session transaction isolation level READ COMMITTED;

-- 开启事务
start transaction;
-- 时刻1 - 事务1读航班余票:
insert into result(t,tickets) 
select 1 t, tickets from ticket where flight_no = 'CZ5525';
commit;
--提交时刻1的事件：读票

-- 添加等待代码，确保事务2的第一次读取在事务1修改前发生
select pg_sleep(1);--wait


-- 时刻3 - 事务1修改余票，并立即读取:
update ticket set tickets = tickets - 1 where flight_no = 'CZ5525';
insert into result(t,tickets)
select 1 t, tickets from ticket where flight_no = 'CZ5525';
--time 3

commit;

-- 时刻6 - 事务1在t2也提交后读取余票
-- 添加代码，确保事务1在事务2提交后读取
select pg_sleep(2);--wait

insert into result(t,tickets)
select 1 t, tickets from ticket where flight_no = 'CZ5525';
commit;

-- 事务2
-- 请设置适当的事务隔离级别以构造不可重复读
set session transaction isolation level READ COMMITTED;
start transaction;
-- 时刻2 - 事务2在事务1读取余票之后也读取余票
-- 添加代码，确保事务2的第1次读发生在事务1读之后，修改之前
select pg_sleep(0.5);--wait
insert into result(t,tickets) 
select 2 t, tickets from ticket where flight_no = 'CZ5525';
commit;
-- 时刻4 - 事务2在事务1修改余票但未提交前再次读取余票，事务2的两次读取结果应该不同
-- 添加代码，确保事务2的读取时机
select pg_sleep(1);--wait
insert into result(t,tickets) 
select 2 t, tickets from ticket where flight_no = 'CZ5525';

-- 事务2立即修改余票
update ticket set tickets = tickets - 1 where flight_no = 'CZ5525';

-- 时刻5 - 事务2 读取余票（自己修改但未交的结果）:

insert into result(t,tickets) 
select  2 t, tickets from ticket where flight_no = 'CZ5525';

commit;

  ```

- 第2关

  请在代码文件t1.sql适当的地方补充代码，要求如下:

  两次查询余票超过300张的航班信息(第2次查询已替你写好)； 

  在第1次查询之后，事务t2插入了一条航班信息并提交(t2.sql已替你写下好)；

   第2次查询的记录数增多,发生“幻读”。 

  不得修改t1的事务隔离级别(保持默认的repeatable read)

  

  分析：

  | time | thing1    | thing2    |
  | ---- | --------- | --------- |
  | 1    | read(0)   | wait      |
  | 2    | wait      | update(1) |
  | 3    | read(1.5) | wait      |

  code:

  ```
  -- 事务1（采用事务隔离级别- read committed）:
  set session transaction isolation level repeatable read;
  
  -- 开启事务
  start transaction;
  
  -- 第1次查询余票超过300张的航班信息
  insert into result
  select *,1 t from ticket where tickets > 300;
  commit;
  -- 修改航班MU5111的执飞机型为A330-300：
  update ticket set aircraft = 'A330-300' where flight_no = 'MU5111'; 
  -- 第2次查询余票超过300张的航班信息
  select pg_sleep(1.5);
  insert into result
  select *,2 t from ticket where tickets > 300;
  commit;
  
  -- 事务2（采用事务隔离级别- read committed）:
  set session transaction isolation level read committed;
  
  -- 开启事务
  start transaction;
  
  select  pg_sleep(1);
  insert into ticket values('MU5111','A330-200',311);
  commit;
  

- 第3关

  ##### OpenGauss对共享锁与锁的支持

  通过设置不同的隔离级别，以实现不同的一致性与并发度的需求是较通常的作法。但OpenGauss也提供了主动加锁的机制，使得在较低的隔离级别下，通过加锁，以实现更高级别的一致性。

  OpenGauss的select语句支持for share和for update短语，分别表示对表加共享(Share)锁和写(write)锁，共享锁也叫读锁，写锁又叫排它锁。 下面这条语句，会对表t1加共享锁: `select * from t1 for share;` 如果select语句涉及多张表，还可分别对不同的表加不同的锁，比如： `select * from t1,t2 for share of t1 for update of t2;`

  加锁短语总是select语句的最后一个短语(复杂的select语句可能有where,group by, having, order by等短语)；

  不管share还是update锁，都是在事务结束时才释放。

  当然，锁行为会降低并发度。

  

  任务：

  现有两个涉及该表的并发事务t1和t2，分别定义在t1.sql和t2.sql代码文件中,请在两个代码文件适当的地方补充代码，实现：

  两个事务的隔离级别都设置成read committed; 

  事务t1连续查询两次航班MU2455的余票； 

  事务t2在t1的两次查询之间试图进行一次出票操作：将航班MU2455的余票减去1张。 

  保证事务t1的两次读结果是一样的(可重复读) 事务t1结束后，在等待t2正常提交(commit)后，再查询一次全部航班的余票,MU2455的余票应该减少1张。

  ```
  -- 事务1: 
  select  pg_sleep(1);
  set session transaction isolation level read committed;
  start transaction;
  -- 第1次查询航班'MU2455'的余票
  
  select tickets from ticket where flight_no = 'MU2455' for share;
  select pg_sleep(5);
  -- 第2次查询航班'MU2455'的余票
  
  select tickets from ticket where flight_no = 'MU2455' for share;
  commit;
  -- 第3次查询所有航班的余票，发生在事务2提交后
  select pg_sleep(1);
  select * from ticket  order by flight_no;
  
  -- 事务2:
  set session transaction isolation level read committed;
  start transaction;
  select pg_sleep(2);
  --在事务1的第1，2次查询之间，试图出票1张(航班MU2455)：
  update ticket set tickets = tickets - 1 where flight_no = 'MU2455';
  commit;
  

- 第4关

  **知识点：**

  ##### 可串行化

  多个事务并发执行是正确的，当且仅当其结果与按某一次序串行地执行这些事务时的结果相同。两个事务t1,t2并发执行，如果结果与t1→t2串行执行的结果相同，或者与t2→t1串行执行的结果相同，都是正确的(可串行化的)。

  如果将事务的隔离级别设置为serializable，则这些事务并发执行，无论怎么调度都会是可串行化的。但这种隔离级别会大大降低并发度，在实践中极小使用。MySQL默认的隔离级别为repeatable read，OpenGauss默认为read committed。

  **任务：**

  现有两个涉及该表的并发事务t1和t2，分别定义在t1.sql和t2.sql代码文件中。事务t1两次查询航班MU2455的余票，事务t2修改航班MU2455的余票(减1)。请对两个代码文件进行修改，使得两个事务并发执行的结果与t2→t1串行执行的结果相同。 除两个事务的select和update语句不可修改外(修改它们会影响输出)，你可以修改、添加代码。但不得将事务的隔离级别设置为serializable，你可以保持默认隔离级别，或设置成其它隔离级别。

  **code:**

  ```
  -- 事务1:
  
  set session transaction isolation level read committed;
  start transaction;
  select pg_sleep(2);
  insert into result
  select *, 1 t from ticket where flight_no = 'MU2455';
  select pg_sleep(2);
  insert into result
  select *,1 t from ticket where flight_no = 'MU2455';
  commit;
  -- 事务2:
  set session transaction isolation level read committed;
  start transaction;
  
  update ticket set tickets = tickets - 1 where flight_no = 'MU2455';
  commit;
  ```

## 数据库应用开发(java)

知识点：

#### JDBC的体系结构

JDBC（Java DataBase Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序。 Java 具有坚固、安全、易于使用、易于理解和可从网络上自动下载等特性，是编写数据库应用程序的杰出语言。所需要的只是 Java应用程序与各种不同数据库之间进行对话的方法。 JDBC可以在各种平台上使用Java，如Windows，Mac OS和各种版本的UNIX。 JDBC API支持用于数据库访问的两层和三层处理模型，但通常，JDBC体系结构由两层组成：

- JDBC API：这提供了应用程序到JDBC管理器连接。
- JDBC驱动程序API：这支持JDBC管理器到驱动程序连接。

#### JDBC的核心组件

JDBC的核心组件包括：

- DriverManager： 此类管理数据库驱动程序列表。使用通信子协议将来自java应用程序的连接请求与适当的数据库驱动程序匹配。
- Driver:此接口处理与数据库服务器的通信，我们很少会直接与Driver对象进行交互。而是使用DriverManager对象来管理这种类型的对象。
- Connection：该界面具有用于联系数据库的所有方法。连接对象表示通信上下文，即，与数据库的所有通信仅通过连接对象。
- Statement：使用从此接口创建的对象将SQL语句提交到数据库。除了执行存储过程之外，一些派生接口还接受参数。
- ResultSet：在使用Statement对象执行SQL查询后，这些对象保存从数据库检索的数据。它作为一个迭代器，允许我们遍历其数据。
- SQLException：此类处理数据库应用程序中发生的任何错误

#### 使用步骤

构建JDBC应用程序涉及以下六个步骤：

- 导入包：需要包含包含数据库编程所需的JDBC类的包。大多数情况下，使用import java.sql.*就足够了。
- 注册JDBC驱动程序：要求您初始化驱动程序，以便您可以打开与数据库的通信通道。
- 打开连接：需要使用DriverManager.getConnection（）方法创建一个Connection对象，该对象表示与数据库的物理连接。
- 执行查询：需要使用类型为Statement的对象来构建和提交SQL语句到数据库。
- 从结果集中提取数据：需要使用相应的ResultSet.getXXX（）方法从结果集中检索数据。
- 释放资源：需要明确地关闭所有数据库资源，而不依赖于JVM的垃圾收集。

建立JDBC连接所涉及的编程可简单概括为以下四个步骤

- 导入JDBC包：将Java语言的*import*语句添加到Java代码中导入所需的类。
- 注册JDBC驱动程序：此步骤将使JVM将所需的驱动程序实现加载到内存中，以便它可以满足您的JDBC请求。
- 数据库URL配置：这是为了创建一个格式正确的地址，指向要连接到的数据库。
- 创建连接对象：最后，调用DriverManager对象的getConnection（）方法来建立实际的数据库连接。

**Class.forName();** 注册驱动程序最常见的方法是使用Java的Class.forName()方法，将驱动程序的类文件动态加载到内存中，并将其自动注册。

```
try {  
	Class.forName("org.postgresql.Driver");
}catch(ClassNotFoundException ex) {  
	System.out.println("Error: unable to load driver class!");  
	System.exit(1);
}
```

**数据库URL配置** 加载驱动程序后，可以使用DriverManager.getConnection（）方法建立连接。为了方便参考，特列出三个重载的DriverManager.getConnection()方法 -

- getConnection（String url）
- getConnection（String url，Properties prop）
- getConnection（String url，String user，String password）

**创建数据库连接对象**

```
String URL = "jdbc:postgresql://localhost:5432/postgres";
String USER = "gaussdb";
String PASS = "Passwd123@123";
Connection conn = DriverManager.getConnection(URL, USER, PASS);
```

简单的连接地址: `jdbc:mysql://127.0.0.1:5432/dbname"`

**关闭数据库连接** 为确保连接关闭，您可以在代码中提供一个“finally”块。一个finally块总是执行，不管是否发生异常。 要关闭上面打开的连接，你应该调用close（）方法如下:  `conn.close();`

**JDBC执行SQL语句** 一旦获得了连接，我们可以与数据库进行交互。JDBC Statement和PreparedStatement接口定义了能够发送SQL命令并从数据库接收数据的方法和属性。

| 接口              | 推荐使用                                                     |
| ----------------- | ------------------------------------------------------------ |
| Statement         | 用于对数据库进行通用访问。在运行时使用静态SQL语句时很有用。Statement接口不能接受参数。不过你可以通过字符串运算，将参数值拼接成一条SQL语句。 |
| PreparedStatement | 当您计划多次使用SQL语句时使用。PreparedStatement接口在运行时接受输入参数。 |

**创建Statement对象**

在使用Statement对象执行SQL语句之前，需要使用Connection对象的createStatement()方法创建Statement的一个实例，如下例所示：

```
 Statement stmt = null;
 try {   
 	stmt = conn.createStatement( );   
 	. . .}   catch (SQLException e) {   
 	. . .}finally {   . . .}
```

**执行Statement对象** 创建Statement对象后，您可以使用它来执行一个SQL语句，其中有三个执行方法之一。

- boolean execute(String SQL)：如果可以检索到ResultSet对象，则返回一个布尔值true; 否则返回false。使用此方法执行SQL DDL语句或需要使用真正的动态SQL时。
- int executeUpdate(String SQL)：返回受SQL语句执行影响的行数。使用此方法执行预期会影响多个行的SQL语句，例如INSERT，UPDATE或DELETE语句。
- ResultSet executeQuery(String SQL)：返回一个ResultSet对象。当您希望获得结果集时，请使用此方法，就像使用SELECT语句一样。

**关闭Statement对象** 就像关闭一个Connection对象以保存数据库资源一样，由于同样的原因，还应该关闭Statement对象。 调用close()方法即可关闭Statement对象。如果先关闭Connection对象，它也会关闭Statement对象。但是，应始终显式关闭Statement对象，以确保正确清理。

```
Statement stmt = null;
try {  
stmt = conn.createStatement( );   
. . .}catch (SQLException e) {   
. . .}finally {stmt.close();}
```

**PreparedStatement** PreparedStatement的接口扩展了Statement接口，其优点是可以动态地提供参数。如果语句被多次执行，其执行效率比Statement高。

```
PreparedStatement pstmt = null;
try {  
String SQL = "Update Employees SET age = ? WHERE id = ?";   
pstmt = conn.prepareStatement(SQL);   
. . .}catch (SQLException e) {   
. . .}finally {   pstmt.close();} 
```

JDBC中的所有参数都用？符号代替，这被称为参数标记(又叫占位符)。在执行SQL语句之前，必须为每个参数提供值。 用setXXX(参数序号,参数值)方法将值绑定到对应参数，其中XXX代表要绑定到输入参数的值的Java数据类型。如果忘记提供值，将收到一个SQLException。参数的序号从1开始。 记得调用close()方法，显示关闭PreparedStatement对象。

**ResultSet** ResultSet对象维护指向结果集中当前行的游标。有多种类型的“游标”，如果没有指定任何ResultSet类型，则取缺省值TYPE_FORWARD_ONLY。

| 类型                              | 类型描述                                                     |
| --------------------------------- | ------------------------------------------------------------ |
| ResultSet.TYPE_SCROLL_INSENSITIVE | 光标可以向前和向后滚动，结果集对创建结果集后发生的数据库的其他更改不敏感。 |
| ResultSet.TYPE_SCROLL_SENSITIVE   | 光标可以向前和向后滚动，结果集对创建结果集之后发生的其他数据库所做的更改敏感。 |
| ResultSet.TYPE_FORWARD_ONLY       | 光标只能在结果集中向前移动。                                 |

**ResultSet的遍历** 用ResultSet的next()方法取得游标当前行的值，并用getXXX(列名)方法获列这一行某个列的值，XXX是与列匹配的数据类型，next()会推进游标到下一行，如果next()返回false表示数据集已取完(或者是空集)。 示例：

```
resultSet = statement.executeQuery("select * from student;");
while (resultSet.next()) {    
System.out.println(resultSet.getString("sno"));    
System.out.println(resultSet.getString("sname"));    
System.out.println(resultSet.getInt("sage"));
} 
```

- 第1关

  正确使用JDBC，查询金融应用场景数据库finance的client表(客户表)中邮箱不为空的客户信息，列出客户姓名，邮箱和电话.

  ```
  /* 请在适当的位置补充代码，完成指定的任务 
     提示：
        try {
  
  
        } catch
      之间补充代码  
  */
  import java.sql.*;
  
  public class Client {
      public static void main(String[] args) {
          Connection connection = null;
          Statement statement = null;
          ResultSet resultSet = null;
  
          try {
              Class.forName("org.postgresql.Driver");
              String URL = "jdbc:postgresql://127.0.0.1:5432/postgres";
              String USER = "gaussdb";
              String PASS = "Passwd123@123";
              connection = DriverManager.getConnection(URL, USER, PASS);
              statement = connection.createStatement( );
              //String SQL="select c_name,c_mail,c_phone from client where c_mail is not null";
              resultSet = statement.executeQuery("SELECT c_name,c_mail,c_phone FROM client WHERE c_mail IS NOT NULL");
              System.out.println("姓名\t邮箱\t\t\t\t电话");
              while (resultSet.next()) {
                  // resultSet.getString("c_name"),"\t",resultSet.getString("c_mail"),resultSet.getString("c_phone")
                  System.out.println(resultSet.getString("c_name")+"\t"+resultSet.getString("c_mail")+"\t\t"+resultSet.getString("c_phone"));
              } 
           } catch (ClassNotFoundException e) {
              System.out.println("Sorry,can`t find the JDBC Driver!"); 
              e.printStackTrace();
          } catch (SQLException throwables) {
              throwables.printStackTrace();
          } finally {
              try {
                  if (resultSet != null) {
                      resultSet.close();
                  }
                  if (statement != null) {
                      statement.close();
                  }
  
                  if (connection != null) {
                      connection.close();
                  }
              } catch (SQLException throwables) {
                  throwables.printStackTrace();
              }
          }
      }
  }
  
  ```

- 第2关

  ##### 条件不确定的查询

  JDBC的Statement类方法executeQuery(sql)可以执行一条确定的sql语句,如果要执行的sql语句带有变化的部分,比如每个客户的输入的用户名与密码都会不同. 这种情况,有两种解决方案:

  **把变量直接拼接到sql语句中** 

  下例中,假定变量userName(类型String)在此前已被赋值:

  ```
  statement = connection.createStatement();
  String sql = "select * from user where username = '" + userName + "';";
  resultSet = statement.executeQuery(sql); 
  ```

  **用PreparedStatement** 用PreparedStatement类,把sql语句中变化的部分当成参数:

  ```
  String sql = "select * from user where username = ? ;";
  preparedStatement = connection.prepareStatement(sql);
  preparedStatement.setString(1,userName);
  resultSet = preparedStatement.executeQuery();
  ```

```
编程体验客户登录功能.程序先后提示客户输用户名和密码:
请输入用户名：
请输入密码：
客户的邮箱(c_mail)充当用户名,而不是编号(c_id).通常邮箱更容易记住.
根据客户的输入,输出以下两类信息之一:
	登录成功。
    用户名或密码错误！ 如果用户名和密码匹配成功,输出前者,其它情况输出后者(包括该用户不存在).通常被恶意用户试探出用户名,也会带来不良后果.

import java.sql.*;
import java.util.Scanner;

public class Login {
    public static void main(String[] args) {
        Connection connection = null;
        //申明下文中的resultSet, statement

        PreparedStatement statement = null;
        ResultSet resultSet = null;

        Scanner input = new Scanner(System.in);

        System.out.print("请输入用户名：");
        String loginName = input.nextLine();
        System.out.print("请输入密码：");
        String loginPass = input.nextLine();

        try {
            Class.forName("org.postgresql.Driver");
            String userName = "gaussdb";
            String passWord = "Passwd123@123";
            String url = "jdbc:postgresql://localhost:5432/postgres";
            connection = DriverManager.getConnection(url, userName, passWord);
            // 补充实现代码:
            String sql="select c_password from client where c_mail=? ;";
            statement=connection.prepareStatement(sql);
            statement.setString(1,loginName);
            resultSet = statement.executeQuery();
            String sqlpassword=null;
            while(resultSet.next()){
                sqlpassword=resultSet.getString("c_password");
            }
            if(sqlpassword!=null&&sqlpassword.contains(loginPass))
                System.out.println("登录成功。");
            else
                System.out.println("用户名或密码错误！");

         } catch (ClassNotFoundException e) {
            e.printStackTrace();
        } catch (SQLException throwables) {
            throwables.printStackTrace();
        } finally {
            try {
                if (resultSet != null) {
                    resultSet.close();
                }
                if (statement != null) {
                    statement.close();
                }

                if (connection != null) {
                    connection.close();
                }
            } catch (SQLException throwables) {
                throwables.printStackTrace();
            }
        }
    }
}
```

- 第3关

实现向client表插入客户信息的方法：

```
import java.sql.*;
import java.util.Scanner;

public class AddClient {
    static final String JDBC_DRIVER = "org.postgresql.Driver";
    static final String DB_URL = "jdbc:postgresql://127.0.0.1:5432/postgres?";
    static final String USER = "gaussdb";
    static final String PASS = "Passwd123@123";
    
    /**
     * 向Client表中插入数据
     *
     * @param connection 数据库连接对象
     * @param c_id 客户编号
     * @param c_name 客户名称
     * @param c_mail 客户邮箱
     * @param c_id_card 客户身份证
     * @param c_phone 客户手机号
     * @param c_password 客户登录密码
     */
    public static int insertClient(Connection connection,
                                   int c_id, String c_name, String c_mail,
                                   String c_id_card, String c_phone, 
                                   String c_password){
        try{
            PreparedStatement statement = null;
            String sql="insert into client (c_id, c_name, c_mail,c_id_card,c_phone, c_password)values(?,?,?,?,?,?)";
            statement=connection.prepareStatement(sql);
            statement.setInt(1,c_id);
            statement.setString(2,c_name);
            statement.setString(3,c_mail);
            statement.setString(4,c_id_card);
            statement.setString(5,c_phone);
            statement.setString(6,c_password);
            int n= statement.executeUpdate();
            return n;
        }catch (SQLException throwables) {
            throwables.printStackTrace();
            return -1;
        }

    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);

        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext())
        {
            String input = sc.nextLine();
            if(input.equals(""))
                break;

            String[]commands = input.split(" ");
            if(commands.length ==0)
                break;
            int id = Integer.parseInt(commands[0]);
            String name = commands[1];
            String mail = commands[2];
            String idCard = commands[3];
            String phone = commands[4];
            String password = commands[5];

            insertClient(connection, id, name, mail, idCard, phone, password);
        }
    }

}

```

- 第4关

实现向银行卡销号的方法，只要客户编号和银行卡号匹配，即从bank_card表中删除该银行卡。

```
import java.sql.*;
import java.util.Scanner;

public class RemoveCard {
    static final String JDBC_DRIVER = "org.postgresql.Driver";
    static final String DB_URL = "jdbc:postgresql://127.0.0.1:5432/postgres?";
    static final String USER = "gaussdb";
    static final String PASS = "Passwd123@123";
    
     /**
     * 删除bank_card表中数据
     *
     * @param connection 数据库连接对象
     * @param b_c_id 客户编号
     * @param c_number 银行卡号
     */
    public static int removeBankCard(Connection connection,
                                   int b_c_id, String b_number){


        try{
            PreparedStatement statement = null;
            String sql="delete from bank_card where b_c_id=? and b_number=?";
            statement=connection.prepareStatement(sql);
            statement.setInt(1,b_c_id);
            statement.setString(2,b_number);
            int n= statement.executeUpdate();
            return n;
        }catch (SQLException throwables) {
            throwables.printStackTrace();
            return -1;
        }

    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);

        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext())
        {
            String input = sc.nextLine();
            if(input.equals(""))
                break;

            String[]commands = input.split(" ");
            if(commands.length ==0)
                break;
            int id = Integer.parseInt(commands[0]);
            String carNumber = commands[1];
            
            int n = removeBankCard(connection, id, carNumber);
            if (n > 0) {
               System.out.println("已销卡数：" + n);
            } else {
               System.out.println("销户失败，请检查客户编号或银行卡号！" );
            }
        }
    }

}

```

- 第5关

实现修改密码的方法passwd()。客户修改密码通常需要确认客户身份，即客户需提供用户名(以邮箱为用户名)和密码，同时还需要输两次新密码，以免客户实际输入的密码与心中想的不一致，只有当所有条件(合法的客户，两次密码输入一致)时才修改密码。main()方法在调用passwd()之前，会先检查新设密码的两次输入是否一致，只有在两次输入一致的情形下才会调用passwd()。

```
import java.sql.*;
import java.util.Scanner;

public class ChangePass {
    static final String JDBC_DRIVER = "org.postgresql.Driver";
    static final String DB_URL = "jdbc:postgresql://127.0.0.1:5432/postgres?";
    static final String USER = "gaussdb";
    static final String PASS = "Passwd123@123";
    
    /**
     * 修改客户密码
     *
     * @param connection 数据库连接对象
     * @param mail 客户邮箱,也是登录名
     * @param password 客户登录密码
     * @param newPass  新密码
     * @return
     *   1 - 密码修改成功
     *   2 - 用户不存在
     *   3 - 密码不正确
     *  -1 - 程序异常(如没能连接到数据库等）
     */
    public static int passwd(Connection connection,
                             String mail,
                             String password, 
                             String newPass){

        
        try{
            PreparedStatement statement = null;
            String sql="select c_password from client where c_mail=? ;";
            statement=connection.prepareStatement(sql);
            statement.setString(1,mail);
            ResultSet resultSet = statement.executeQuery();
            String sqlpassword=null;
            while(resultSet.next()){
                sqlpassword=resultSet.getString("c_password");
            }
            if(sqlpassword==null) return 2;
            if(!sqlpassword.contains(password)) return 3;
            PreparedStatement upstatement = null;
            String newsql="update client set c_password=?  where c_mail=?";
            upstatement=connection.prepareStatement(newsql);
            upstatement.setString(1,newPass);
            upstatement.setString(2,mail);
            int n= upstatement.executeUpdate();
            return n;
        }catch (SQLException throwables) {
            throwables.printStackTrace();
            return -1;
        }



    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);

        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext())
        {
            String input = sc.nextLine();
            if(input.equals(""))
                break;

            String[]commands = input.split(" ");
            if(commands.length ==0)
                break;
            String email = commands[0];
            String pass = commands[1];
            String pwd1 = commands[2];
            String pwd2 = commands[3];
            if (pwd1.equals(pwd2)) {
              int n = passwd(connection, email, pass, pwd1);  
              System.out.println("return: " + n);
            } else {
              System.out.println("两次输入的密码不一样!");
            }
        }
    }

}

```

- 第6关 事务与转账操作

  transferBalance()返回boolean值，true表示转帐成功，false表示转账失败，并不需要细分或解释失败的原因。 

  下列任一情形都不可转账(转账失败的原因)：

  转出或转入帐号不存在 

  转出账号是信用卡 

  转出帐号余额不足

```
import java.sql.*;
import java.util.Scanner;

public class Transfer {
    static final String JDBC_DRIVER = "org.postgresql.Driver";
    static final String DB_URL = "jdbc:postgresql://127.0.0.1:5432/postgres?";
    static final String USER = "gaussdb";
    static final String PASS = "Passwd123@123";
    /**
     * 转账操作
     *
     * @param connection 数据库连接对象
     * @param sourceCard 转出账号
     * @param destCard 转入账号
     * @param amount  转账金额
     * @return boolean
     *   true  - 转账成功
     *   false - 转账失败
     */
    public static boolean transferBalance(Connection connection,
                             String sourceCard,
                             String destCard, 
                             double amount){
    try{
        connection.setAutoCommit(false);//关闭自动提交
        PreparedStatement sourcestate = null;//声明
        ResultSet result = null;//游标
        String selectcard="select b_balance,b_type from bank_card where b_number=?;";
        sourcestate = connection.prepareStatement(selectcard);//连接
        sourcestate.setString(1,sourceCard);//传参
        result=sourcestate.executeQuery();//运行
        double source_balance=0;
        String source_type = null;
        while(result.next())
        {
            source_type=result.getString("b_type");
            source_balance = result.getDouble("b_balance");
        }//结果赋值
        if(source_type == null) return false;//转出账号不存在
        if(source_type.contains("信用卡")) return false;//转出账号是信用卡
        if(source_balance<amount) return false;//转出账号余额不足
        PreparedStatement deststate = null;//声明
        result = null;
        deststate = connection.prepareStatement(selectcard);//连接
        deststate.setString(1,destCard);//传参
        result=deststate.executeQuery();//运行
        if(result == null) return false;
        String dest_type=null;
        while(result.next())
        {
            dest_type=result.getString("b_type");
        }
        if(dest_type==null) return false;//转入账号不存在
        String updatecard="update bank_card set b_balance=b_balance-? where b_number=?;";
        PreparedStatement statement = connection.prepareStatement(updatecard);//声明连接
        statement.setDouble(1,amount);//传参
        statement.setString(2,sourceCard);//传参
        int f=statement.executeUpdate();//运行减少转出账号余额
        if(f<=0) return false;
        if(dest_type.contains("信用卡")){
            statement.setDouble(1,amount);
            statement.setString(2,destCard);
        }
        else{
            statement.setDouble(1,amount*(-1));
            statement.setString(2,destCard);
        }
        f=statement.executeUpdate();//运行转入账号余额
        if(f<=0) return false;
        connection.commit();//提交
        return true;
    }catch(SQLException throwables) {
        throwables.printStackTrace();
    } 
    return true;
    }

    // 不要修改main() 
    public static void main(String[] args) throws Exception {

        Scanner sc = new Scanner(System.in);
        Class.forName(JDBC_DRIVER);

        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);

        while(sc.hasNext())
        {
            String input = sc.nextLine();
            if(input.equals(""))
                break;

            String[]commands = input.split(" ");
            if(commands.length ==0)
                break;
            String payerCard = commands[0];
            String  payeeCard = commands[1];
            double  amount = Double.parseDouble(commands[2]);
            if (transferBalance(connection, payerCard, payeeCard, amount)) {
              System.out.println("转账成功。" );
            } else {
              System.out.println("转账失败,请核对卡号，卡类型及卡余额!");
            }
        }
    }

}

```

- 第7关 稀疏表格转为键值对存储

  将一个稀疏的表中有保存数据的列值，以键值对(列名，列值 )的形式转存到另一个表中，这样可以直接丢失没有值列。

```
import java.sql.*;

public class Transform {
  static final String JDBC_DRIVER = "org.postgresql.Driver";
    static final String DB_URL = "jdbc:postgresql://127.0.0.1:5432/postgres?";
    static final String USER = "gaussdb";
    static final String PASS = "Passwd123@123";
    static final String[] all_kemu={"chinese","math","english","physics","chemistry","biology","history","geography","politics"};
    /**
     * 向sc表中插入数据
     *
     */
    public static int insertSC( Connection connection,int sno,String kemu,String score){
      try{
        String sql="insert into sc (sno,col_name,col_value)values(?,?,?);";
        PreparedStatement statement=connection.prepareStatement(sql);
        statement.setInt(1,sno);
        statement.setString(2,kemu);
        statement.setString(3,score);
        int n=statement.executeUpdate();
        return n;
      }catch(SQLException throwables) {
        throwables.printStackTrace();
      } 
      return 0;
    }

    public static void main(String[] args) {
      try{
        Class.forName(JDBC_DRIVER);//后面一定要ClassNotFoundException
        Connection connection = DriverManager.getConnection(DB_URL, USER, PASS);
      
        int sno;
        String score = null;
        String sql="select sno,chinese,math,english,physics,chemistry,biology,history,geography,politics from entrance_exam;";
        PreparedStatement statement=connection.prepareStatement(sql);//声明连接
        ResultSet result=statement.executeQuery();//运行
        while(result.next())//游标遍历
        {
          sno=result.getInt("sno");
          for(int i=0;i<9;i++)
          {
            score=null;
            String kemu=all_kemu[i];
            score=result.getString(all_kemu[i]);
            if(score!=null){
              int n=insertSC(connection,sno,all_kemu[i],score);//调用函数插入
              if(n<=0) System.out.print("insert error!\n");
            }
          }
        }
      }catch(ClassNotFoundException e){
				e.printStackTrace();
			}catch(SQLException throwables) {
        throwables.printStackTrace();
      } 
    }
}
```

## 备份+日志

#### OpenGauss的恢复机制

和大多数DBMS一样，OpenGauss利用备份、日志文件实现恢复。具体理论知识在此不详细介绍。OpenGauss提供了gs_dump工具用于数据导出，gs_restore工具用于数据导入。

#### gs_dump数据导出工具

  openGauss支持使用gs_dump工具导出某个数据库级的内容，包含数据库的数据和所有对象定义。  注意事项： ● 禁止修改导出的文件和内容，否则可能无法恢复成功。 ● 为了保证数据一致性和完整性，导出工具会对需要转储的表设置共享锁。如果表在别的事务中设置了共享锁，gs_dump会等待锁释放后锁定表。如果无法在指定时间内锁定某个表，转储会失败。用户可以通过指定--lock-waittimeout选项，自定义等待锁超时时间。 ●gs_dump常用参数说明 表1 gs_dump常用参数说明

| 参数 | 参数说明                                                     | 举例               |
| ---- | ------------------------------------------------------------ | ------------------ |
| -U   | 连接数据库的用户名。                                         | -U gaussdb         |
| -W   | 指定用户连接的密码。                                         | -W 'Passwd123@123' |
| -f   | 将导出文件发送至指定目录文件夹。                             | 无                 |
| -p   | 指定服务器所侦听的TCP端口或本地Unix域套接字后缀，以确保连接。 | -p 5432            |
| -d   | 需要导出的数据库名称.                                        | -d residents       |
| -F   | 选择导出文件格式。-F参数值如下：（1）p：纯文本格式（2）c：自定义归档（3）d：目录归档格式（4）t：tar归档格式 | -F t               |

示例：`gs_dump -U gaussdb -W'Passwd123@123' -h localhost -p5432 postgres -f residents_bak.tar`

#### gs_restore数据导入工具

gs_restore是openGauss数据库提供的与gs_dump配套的导入工具。通过该工具，可将gs_dump导出的文件导入至数据库。 ●gs_restore常用参数说明 表2 gs_restore常用参数说明

| 参数 | 参数说明                                                     | 举例               |
| ---- | ------------------------------------------------------------ | ------------------ |
| -U   | 连接数据库的用户名。                                         | -U gaussdb         |
| -W   | 指定用户连接的密码。                                         | -W 'Passwd123@123' |
| -f   | 将导出文件发送至指定目录文件夹。                             | 无                 |
| -p   | 指定服务器所侦听的TCP端口或本地Unix域套接字后缀，以确保连接。 | -p 5432            |
| -d   | 需要导出的数据库名称.                                        | -d residents       |
| -F   | 选择导出文件格式。-F参数值如下：（1）p：纯文本格式（2）c：自定义归档（3）d：目录归档格式（4）t：tar归档格式 | -F t               |

示例：`gs_restore -U gaussdb -W'Passwd123@123'  backup.tar -p5432  -d residents`



任务：

设有居民人口登记数据库residents,请用gs_dump工具为该数据库做一次静态的(你一个人独享服务器)海量备份，备份文件为.tar格式文件； 然后再用gs_restore工具，利用前述备份文件恢复数据库residents。 评测程序并不检查备份文件的名字，你可以用其它文件名，但要保证备份和恢复时，使用同一个文件。备份和恢复的命令分别写在test1_1.sh和test1_2.sh文件中。

- test1_1.sh - 作备份
- test1_2.sh - 作恢复

```
--备份
gs_dump -U gaussdb -W'Passwd123@123' -h localhost -p5432 residents -F t -f residents_bak.tar
--恢复
gs_restore -U gaussdb -W'Passwd123@123'  residents_bak.tar -p5432 -d residents
```

## 数据库设计与实现

- 第1关：概念模型

  

  ```
   # 请将你实现flight_booking数据库的语句写在下方：
  
  drop table if exists "user";
  create table "user"(
      user_id int primary key,
      firstname varchar(50) not null,
      lastname varchar(50) not null,
      dob date not null,
      sex char(1) not null,
      email varchar(50) default(''),
      phone varchar(30)default(''),
      username varchar(20) not null,
      "password" char(32) not null,
      admin_tag tinyint default(0) not null
  );
  create unique index user_index1 on "user"(username);
  
  drop table if exists passenger;
  create table passenger(
      passenger_id int primary key,
      id char(18) not null,
      firstname varchar(50) not null,
      lastname varchar(50) not null,
      mail varchar(50) default(''),
      phone varchar(20) not null,
      sex char(1) not null,
      dob timestamp
  );
  create unique index passenger_index1 on passenger(id);
  
  drop table if exists airport;
  create table airport(
      airport_id smallint primary key,
      iata char(3)  not null,
      icao char(4)  not null,
      "name" varchar(50) not null,
      city varchar(50) default(''),
      country varchar(50) default(''),
      latitude decimal(11,8) default(0),
      longitude decimal(11,8) default(0)
  );
  create index airport_index1 on airport("name");
  create unique index airport_index2 on airport(iata);
  create unique index airport_index3 on airport(icao); 
  
  drop table if exists airline;
  create table airline(
      airline_id int primary key,
      "name" varchar(30) not null,
      iata char(2) not null,
      airport_id smallint not null,
      constraint airline_airport foreign key(airport_id) references airport(airport_id)
  );
  create unique index airline_index1 on airline(iata);
  create index airline_index3 on airline(airport_id);
  
  drop table if exists airplane;
  create table airplane(
      airplane_id int primary key,
      "type" varchar(50) not null,
      capacity smallint not null,
      identifier varchar(50) not null,
      airline_id int not null,
      constraint airplane_airline foreign key(airline_id) references airline(airline_id)
  );
  create index airplane_index1 on airplane(airline_id);
  
  
  drop table if exists flightschedule;
  create table flightschedule(
      flight_no char(8) primary key,
      departure timestamp not null,
      arrival timestamp not null,
      duration smallint  not null,
      monday tinyint default(0),
      tuesday tinyint  default(0),
      wednesday tinyint default(0),
      thursday tinyint default(0),
      friday tinyint default(0),
      saturday tinyint default(0),
      sunday tinyint default(0),
      "from" smallint not null,
      "to" smallint not null,
      airline_id int not null,
      constraint flightschedule_airport1 foreign key("from") references airport(airport_id),
      constraint flightschedule_airport2 foreign key("to") references airport(airport_id),
      constraint flightschedule_airline foreign key(airline_id) references airline(airline_id)
  );
  create index flightschedule_index1 on flightschedule(airline_id);
  create index flightschedule_index3 on flightschedule("from");
  create index flightschedule_index4 on flightschedule("to");
  
  drop table if exists flight;
  create table flight(
      flight_id int primary key,
      departure timestamp not null,
      arrivals timestamp not null,
      duration smallint not null,
      "from" smallint not null,
      "to" smallint not null,
      airline_id int not null,
      airplane_id int not null,
      flight_no char(8) not null,
      constraint flight_airport1 foreign key("from") references airport(airport_id),
      constraint flight_airport2 foreign key("to") references airport(airport_id),
      constraint flight_airline foreign key(airline_id) references airline(airline_id),
      constraint flight_flightschedule foreign key(flight_no) references flightschedule(flight_no),
      constraint flight_airplane foreign key(airplane_id) references airplane(airplane_id)
  );
  create index flight_index1 on flight(airline_id);
  create index flight_index2 on flight(arrivals);
  create index flight_index3 on flight(departure);
  create index flight_index5 on flight(flight_no);
  create index flight_index6 on flight("from");
  create index flight_index7 on flight("to");
  
  drop table if exists ticket;
  create table ticket(
      ticket_id int primary key,
      seat char(4)default(''),
      price numeric(10,2) not null,
      user_id int not null,
      flight_id int not null,
      passenger_id int not null,
      constraint ticket_passenger foreign key(passenger_id) references passenger(passenger_id),
      constraint ticket_flight foreign key(flight_id) references flight(flight_id),
      constraint ticket_user foreign key(user_id) references "user"(user_id)
  );
  create index ticket_index1 on ticket(flight_id);
  create index ticket_index2 on ticket(passenger_id);
  create index ticket_index4 on ticket(user_id);
  
  ```

  

- 第2关：逻辑模型

  ```
   请给出ER图文件存放的URL:
  https://gitee.com/DayDreamSpace/hust-database-13-2/blob/master/ersolution.jpg
   以下给出关系模式：
  
  顾客(c_id,name,phone),primary key:c_id;
  电影票(ticket_id,seat_num),primary key:ticket_id;
  电影(movie_id,title,type,runtime,release_date,director,starring),primary key:movie_id;
  放映厅(hall_id,mode,capacity,location),primary key:hall_id;
  排场(schedule_id,date,time,price,number),primary key:schedule_id;
  
  MC(ticket_id,movie_id,schedule_id,hall_id,custormer_id),primary key:ticket_id;
  ```

- 第3关：建模工具

  ```
   # 请将利用MySQL Workbench软件的Modeling工具，经forward engineering 导出的创建schema的SQL语句完整粘到此处：
  
  drop table apgroup;
  
  drop table apmodule;
  
  drop table apright;
  
  drop table aprole;
  
  drop table apuser;
  
  /*==============================================================*/
  /* Table: aprole                                                */
  /*==============================================================*/
  create table aprole (
     RoleNo               INT4                 not null,
     RoleName             CHAR(20)             not null,
     Comment              VARCHAR(50)          null default NULL,
     Status               INT2                 null default NULL,
     constraint PK_APROLE primary key (RoleNo)
  );
  
  comment on column aprole.RoleNo is
  '角色编号';
  
  comment on column aprole.RoleName is
  '角色名';
  
  comment on column aprole.Comment is
  '角色描述';
  
  comment on column aprole.Status is
  '角色状态';
  
  /*==============================================================*/
  /* Table: apuser                                                */
  /*==============================================================*/
  create table apuser (
     UserID               CHAR(8)              not null,
     UserName             CHAR(8)              null default NULL,
     Comment              VARCHAR(50)          null default NULL,
     PassWord             CHAR(32)             null default NULL,
     Status               INT2                 null default NULL,
     constraint PK_APUSER primary key (UserID),
     constraint ind_username unique (UserName)
  );
  
  comment on column apuser.UserID is
  '用户工号';
  
  comment on column apuser.UserName is
  '用户姓名';
  
  comment on column apuser.Comment is
  '用户描述';
  
  comment on column apuser.PassWord is
  '口令';
  
  comment on column apuser.Status is
  '状态';
  
  /*==============================================================*/
  /* Table: apgroup                                               */
  /*==============================================================*/
  create table apgroup (
     UserID               CHAR(8)              not null,
     RoleNo               INT4                 not null,
     constraint PK_APGROUP primary key (UserID, RoleNo),
     constraint FK_apGroup_apRole2 unique (RoleNo),
     constraint FK_apGroup_apRole foreign key (RoleNo)
        references aprole (RoleNo),
     constraint FK_apGroup_apUser foreign key (UserID)
        references apuser (UserID)
  );
  
  comment on column apgroup.UserID is
  '用户编号';
  
  comment on column apgroup.RoleNo is
  '角色编号';
  
  /*==============================================================*/
  /* Table: apmodule                                              */
  /*==============================================================*/
  create table apmodule (
     ModNo                INT8                 not null,
     ModID                CHAR(10)             null default NULL,
     ModName              CHAR(20)             null default NULL,
     constraint PK_APMODULE primary key (ModNo)
  );
  
  comment on column apmodule.ModNo is
  '模块编号';
  
  comment on column apmodule.ModID is
  '系统或模块的代码';
  
  comment on column apmodule.ModName is
  '系统或模块的名称';
  
  /*==============================================================*/
  /* Table: apright                                               */
  /*==============================================================*/
  create table apright (
     RoleNo               INT4                 not null,
     ModNo                INT8                 not null,
     constraint PK_APRIGHT primary key (RoleNo, ModNo),
     constraint FK_apRight_apModule2 unique (ModNo),
     constraint FK_apRight_apModule foreign key (ModNo)
        references apmodule (ModNo),
     constraint FK_apRight_apRole foreign key (RoleNo)
        references aprole (RoleNo)
  );
  
  comment on column apright.RoleNo is
  '角色编号';
  
  comment on column apright.ModNo is
  '模块编号';
  ```
  
  

## B+tree

- 第1关：BPlusTreePage的设计

  **知识点**

  ##### BPlusTreePage 结构简述

  BPlusTreePage作为BPlusTreeInternalPage与BPlusTreeInternalPage父类，包含了B+树结点的基本信息和功能，比如结点类型，包含元素存储最大值以及现存元素个数，父结点id，当前结点id。

  ##### 相关变量声明

  ```
  //B+树结点类型定义，定义在b_plus_tree_page.cpp中
  enum class IndexPageType 
  { INVALID_INDEX_PAGE = 0, LEAF_PAGE, INTERNAL_PAGE };//无效结点，定义在config.h中，可直接使用该常量
  static constexpr int INVALID_PAGE_ID = -1;                                    // invalid page id
  //B+树中页的唯一标识
  page_id_t page_id_;
  ```

​	**任务：**

​		请在b_plus_tree_page.cpp文件中实现下列函数：

```
  bool IsLeafPage() const;  
  bool IsRootPage() const;  
  void SetPageType(IndexPageType page_type);  
  int GetSize() const;  void SetSize(int size);  
  void IncreaseSize(int amount);  
  int GetMaxSize() const;  
  void SetMaxSize(int max_size);  
  int GetMinSize() const;  
  page_id_t GetParentPageId() const;  
  void SetParentPageId(page_id_t parent_page_id);  
  page_id_t GetPageId() const;  
  void SetPageId(page_id_t page_id);  
  void SetLSN(lsn_t lsn = INVALID_LSN);
```

​	**code：**

```
//b_plus_tree_page.h

#pragma once

#include <cassert>
#include <climits>
#include <cstdlib>
#include <string>

#include "buffer/buffer_pool_manager.h"
#include "storage/index/generic_key.h"

namespace bustub {

#define MappingType std::pair<KeyType, ValueType>

#define INDEX_TEMPLATE_ARGUMENTS template <typename KeyType, typename ValueType, typename KeyComparator>

/* 定义索引类型
*  
*
* 
*/
enum class IndexPageType { INVALID_INDEX_PAGE = 0, LEAF_PAGE, INTERNAL_PAGE };

/**
 * 内部结点和叶结点均继承自该结点
 *
 * BPlusTreePage存储在Page类的data中，处于Page的首部
 */
class BPlusTreePage {
 public:
  
  bool IsLeafPage() const;
  bool IsRootPage() const;
  void SetPageType(IndexPageType page_type);

  int GetSize() const;
  void SetSize(int size);
  void IncreaseSize(int amount);

  int GetMaxSize() const;
  void SetMaxSize(int max_size);
  int GetMinSize() const;

  page_id_t GetParentPageId() const;
  void SetParentPageId(page_id_t parent_page_id);

  page_id_t GetPageId() const;
  void SetPageId(page_id_t page_id);

  void SetLSN(lsn_t lsn = INVALID_LSN);

 private:
  //页的类型,取值enum IndexPageType
  IndexPageType page_type_ __attribute__((__unused__));
  //日志序列号，用于并发索引
  lsn_t lsn_ __attribute__((__unused__));
  //一个页里的键值对数量
  int size_ __attribute__((__unused__));
  //一个页里的键值对最大数量
  int max_size_ __attribute__((__unused__));
  //父结点的页ID，根节点是没有父节点，可以定义根节点的parent_page_id_=INVALID_PAGE_ID
  //定义于config.h,static constexpr int INVALID_PAGE_ID = -1;
  page_id_t parent_page_id_ __attribute__((__unused__));
  //本结点的id
  page_id_t page_id_ __attribute__((__unused__));
};

}

```

```
//b_plus_tree_page.cpp
#include "storage/page/b_plus_tree_page.h"

namespace bustub {
/*
 * 函数功能：
 * 判断页类型是否为叶子结点
 * 建议：
 * enum class IndexPageType { INVALID_INDEX_PAGE = 0, LEAF_PAGE, INTERNAL_PAGE }
 * （定义于b_plus_tree_page.h头文件中）
 */
bool BPlusTreePage::IsLeafPage() const {
  if(page_type_ == IndexPageType::LEAF_PAGE) return true;
  return false;
}
/*
 * 函数功能：
 *  判断页类型是否为根结点
 * 建议：
 *  static constexpr int INVALID_PAGE_ID = -1;// invalid page id（定义与config.h中）
 *  父节点pageId为INVALID_PAGE_ID时即为根结点
 */
bool BPlusTreePage::IsRootPage() const {
  if(parent_page_id_ == INVALID_PAGE_ID) return true;
  return false;
}
/*
 * 函数功能：
 *    设置索引页类型
 */
void BPlusTreePage::SetPageType(IndexPageType page_type) { 
  	page_type_=page_type;
}

/*
 * 函数功能：
 *  get/set size (size：当前结点中存放的元素（键值对）个数)
 *  IncreaseSize 增加结点元素大小
 */
int BPlusTreePage::GetSize() const {
  	return size_;
 }
void BPlusTreePage::SetSize(int size) {
  	size_ = size;
  	return;
}
void BPlusTreePage::IncreaseSize(int amount) {
  	size_ += amount;
}

/*
 * 函数功能：
 *  get/set max size
 */
int BPlusTreePage::GetMaxSize() const {  
  	return max_size_;
}
void BPlusTreePage::SetMaxSize(int size) {
  	max_size_=size;
  	return;
}

/*
 * 函数功能：
 *  获取当前结点允许的最少元素个数
 * 建议：
 *  1.如果此时为根节点：根节点可能是内部节点也可能是叶子节点
 *  内部节点：此时至少存在两个索引
 *  叶子节点：此时至少存在一条记录
 *  2.非根结点正常处理，至少要求是半满以上
 *    如果是叶结点，[(max_size_-1)/2]=(max_size_-1+1)/2
 *    如果是内部结点，第一个key是不使用的，(max_size_-1-1+1)/2+1
 */
int BPlusTreePage::GetMinSize() const {
      if(parent_page_id_==INVALID_PAGE_ID){
            if(page_type_==IndexPageType::LEAF_PAGE) return 1;
            else return 2; 
      }
      else{
            if(page_type_==IndexPageType::LEAF_PAGE) return (max_size_-1+1)/2;
            else return (max_size_-1-1+1)/2+1;
      }
}

/*
 *函数功能：
 *  get/set parent page id
 * 提示：
 *  1.设置结点的父节点方法只能通过SetParentPageId来实现 
 */
page_id_t BPlusTreePage::GetParentPageId() const { 
  	return parent_page_id_;
 }
void BPlusTreePage::SetParentPageId(page_id_t parent_page_id) {  
      parent_page_id_=parent_page_id;
      return;
}

/*
 *函数功能：
 *  get/set self page id
 */
page_id_t BPlusTreePage::GetPageId() const { 
  	return page_id_;
 }
void BPlusTreePage::SetPageId(page_id_t page_id) { 
      page_id_=page_id;
      return;
 }

/*
 *函数功能：
 * set lsn
 */
void BPlusTreePage::SetLSN(lsn_t lsn) {  lsn_ = lsn;  }

}
```

- 第2关：BPlusTreeInternalPage的设计

  #### BPlusTreeInternalPage 结构简述

  内部页不存储任何实际数据，而是存储有序的m个键条目和m + 1个指针（也称为page_id）。 由于指针的数量不等于键的数量，因此将第一个键设置为无效，并且查找方法应始终从第二个键开始。 任何时候，每个内部页面至少有一半已满。 在删除期间，可以将两个半满页面合并为合法页面，或者可以将其重新分配以避免合并，而在插入期间，可以将一个完整页面分为两部分。 内部结点成员在BPlusTreePage的基础上额外增加一个数组，用于存储索引信息。 一个Max_size为n的内部结点，有n-1个索引键和n个子结点索引（由于二者数量不相同，一般第一个索引键为无效键），即该数组有如下结构：

  | INVALID_KEY+PAGE_ID(0) | KEY(1)+PAGE_ID(1) | ...  | KEY(n)+PAGE_ID(n) |
  | ---------------------- | ----------------- | ---- | ----------------- |

  键在数组中维持有序排列。

  ### 相关变量声明

  ```
  //BPlusTreeInternalPage中的索引数组
  MappingType array_[0];
  //索引键值对，内部结点中为<Key,page_id_t> 
  //using page_id_t = int32_t
  MappingType std::pair<KeyType, ValueType>
  //缓冲区对象，负责特定页的获取
  BufferPoolManager *buffer_pool_manager
  //比较器，负责键的比较
  KeyComparator &comparator
  ```

  ### 关卡内容

  请在b_plus_tree_internal_page.cpp文件中实现下列函数：

  ```
    void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int max_size = INTERNAL_PAGE_SIZE);  
    KeyType KeyAt(int index) const;  
    void SetKeyAt(int index, const KeyType &key);  
    int ValueIndex(const ValueType &value) const;  
    ValueType ValueAt(int index) const;  
    ValueType Lookup(const KeyType &key, const KeyComparator &comparator) const;  
    void PopulateNewRoot(const ValueType &old_value, const KeyType &new_key, const ValueType &new_value);  
    int InsertNodeAfter(const ValueType &old_value, const KeyType &new_key, const ValueType &new_value);  
    void Remove(int index);  
    ValueType RemoveAndReturnOnlyChild();  
    void MoveAllTo(BPlusTreeInternalPage *recipient,BufferPoolManager *buffer_pool_manager);  
    void MoveHalfTo(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager);  
    void MoveFirstToEndOf(BPlusTreeInternalPage *recipient,                        BufferPoolManager *buffer_pool_manager);  
    void MoveLastToFrontOf(BPlusTreeInternalPage *recipient,                          BufferPoolManager *buffer_pool_manager);  
    std::string ToString(bool verbose) const;  
    void CopyNFrom(MappingType *items, int size, BufferPoolManager *buffer_pool_manager);  
    void CopyLastFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager);  
    void CopyFirstFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager);
  ```

  #### **code：**

  ```
  //b_plus_tree_internal_page.h
  
  #pragma once
  
  #include <queue>
  
  #include "storage/page/b_plus_tree_page.h"
  
  namespace bustub {
  
  #define B_PLUS_TREE_INTERNAL_PAGE_TYPE BPlusTreeInternalPage<KeyType, ValueType, KeyComparator>
  #define B_PLUS_TREE_INTERNAL_PAGE BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator>
  #define INTERNAL_PAGE_HEADER_SIZE 24
  //缺省时内部结点的Max_size
  #define INTERNAL_PAGE_SIZE ((PAGE_SIZE - INTERNAL_PAGE_HEADER_SIZE) / (sizeof(MappingType))) - 1
  
  INDEX_TEMPLATE_ARGUMENTS
  class BPlusTreeInternalPage : public BPlusTreePage {
   public:
    void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int max_size = INTERNAL_PAGE_SIZE);
  
    KeyType KeyAt(int index) const;
    void SetKeyAt(int index, const KeyType &key);
    int ValueIndex(const ValueType &value) const;
    ValueType ValueAt(int index) const;
  
    ValueType Lookup(const KeyType &key, const KeyComparator &comparator) const;
    void PopulateNewRoot(const ValueType &old_value, const KeyType &new_key, const ValueType &new_value);
    int InsertNodeAfter(const ValueType &old_value, const KeyType &new_key, const ValueType &new_value);
    void Remove(int index);
    ValueType RemoveAndReturnOnlyChild();
  
    void MoveAllTo(BPlusTreeInternalPage *recipient,BufferPoolManager *buffer_pool_manager);
    void MoveHalfTo(BPlusTreeInternalPage *recipient, BufferPoolManager *buffer_pool_manager);
    void MoveFirstToEndOf(BPlusTreeInternalPage *recipient,
                          BufferPoolManager *buffer_pool_manager);
    void MoveLastToFrontOf(BPlusTreeInternalPage *recipient, 
                           BufferPoolManager *buffer_pool_manager);
  
   private:
    void CopyNFrom(MappingType *items, int size, BufferPoolManager *buffer_pool_manager);
    void CopyLastFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager);
    void CopyFirstFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager);
    MappingType array_[0];
  };
  }
  
  ```

  ```
  //b_plus_tree_internal_page.cpp
  
  #include <iostream>
  #include <sstream>
  
  #include "common/exception.h"
  #include "storage/page/b_plus_tree_internal_page.h"
  /*
   *内部结点实现说明：
   *    本文件主要实现内部结点的初始化、查找、分裂，合并以及重分配等
   *  算法。因为内部结点的变动（分裂，合并以及重分配）会产生迭代，
   *  因此在这些算法中，要特别注意this结点的父节点的设置。
   *  
   *  
   *  
   */
  
  namespace bustub {
  /*
   * 函数功能：
   *  初始化this页，包括page type,size,page id,parent id and max page size
   *  输入：
   *    page_id_t page_id 页号
   *    page_id_t parent_id 父页号
   *    int max_size 页元素最大值
   *  提示：因为是内部页类，因此页类型应该设置为IndexPageType::INTERNAL_PAGE
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::Init(page_id_t page_id, page_id_t parent_id, int max_size) {
      SetPageType(IndexPageType::INTERNAL_PAGE);
      SetSize(0);
      SetPageId(page_id);
      SetParentPageId(parent_id);
      SetMaxSize(max_size);
  }
  
  /*
   * 函数功能：
   *  返回index处的key值
   * 建议：
   *   1.leaf页数组中元素为pair，first为key，second为RID
   *   2.internal页数组中元素为pair，first为key，second为PAGE_ID
   */
  INDEX_TEMPLATE_ARGUMENTS
  KeyType B_PLUS_TREE_INTERNAL_PAGE_TYPE::KeyAt(int index) const {
      return array_[index].first;
  }
  /*
   * 函数功能：
   *  设置index处的key值
   * 建议：
   *   
   *   1.internal数组中元素为pair，first为key，second为PAGE_ID
   */
  
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::SetKeyAt(int index, const KeyType &key) { 
    array_[index].first=key;
    return;
  }
  
  /*
   * 函数功能：
   *  寻找当前结点所有的键值（key）对中值为value的元素的索引
   * 建议：
   *  1.如果未找到，返回-1
   */
  INDEX_TEMPLATE_ARGUMENTS
  int B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueIndex(const ValueType &value) const {
      for(int i=0;i<GetSize();i++)
      {
        if(array_[i].second==value) return i;
      }
      return -1;
  }
  /*
   * 函数功能：
   *  返回索引index处的value
   *
   */
  INDEX_TEMPLATE_ARGUMENTS
  ValueType B_PLUS_TREE_INTERNAL_PAGE_TYPE::ValueAt(int index) const {
      return array_[index].second;
  }
  
  /*****************************************************************************
   * 查找
   *****************************************************************************/
  /*
   * 函数功能：
   *  在key值有序排列的数组中，找到特定key值对应的value
   * 建议：
   *  1.选择合适查找法
   *  2.如果key值不存在，返回最接近的较小key对应的value
   *  3.使用comparator进行key值的比较
   */
  INDEX_TEMPLATE_ARGUMENTS
  ValueType B_PLUS_TREE_INTERNAL_PAGE_TYPE::Lookup(const KeyType &key, const KeyComparator &comparator) const {
    assert(GetSize() > 1);
    int l=0,h=GetSize()-1;
    while(l<=h){
      int m=(l+h)/2;
      int f=comparator(array_[m].first,key);
      if(f<0) l=m+1;
      else if(f>0) h=m-1;
      else return array_[m].second;
    }
    return array_[h].second;
  
  }
  
  /*****************************************************************************
   * 内部结点分裂
   *****************************************************************************/
  /* 使用场景
   *  当根结点中元素过多时，会在分裂后原来的根节点会变为内部结点，同时要创建新的根节点
   *  对新创建的根节点需要初始化
   * 函数功能：
   *  对新的根结点进行初始化填充
   * 建议：
   *  1.该函数仅在InsertIntoParent()(b_plus_tree.cpp)中调用
   *  2.初始化后根结点中元素为[<invalid, old_value>, <new_key, new_value>]
   *  3.当节点分裂时，分裂的new_Key需要通过函数InsertIntoParent()插入到父节点中，
   *    如果当前节点为根节点，那么需要创建新的根节点，并通过PopulateNewRoot函数初始化它
   *  4.更新size=2
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::PopulateNewRoot(const ValueType &old_value, const KeyType &new_key,
                                                       const ValueType &new_value) {
    //该函数为由于底层变动生成新的根元素，此时对该根元素进行设置
    array_[0].second = old_value;
    array_[1].first = new_key;
    array_[1].second = new_value;
    SetSize(2);
    return;
  }
  /* 使用场景：
   *  B+树的插入：当B+树结点分裂，会创造一个新的split结点，通过调用InsertIntoParent函数
   *  将新的split结点插入到父节点，在InsertIntoParent函数中需要调用InsertNodeAfter进行
   *  插入。
   * 函数功能：
   *  在当前page中找到old_value的位置，然后将new_key和new_value插入其中
   * 建议：
   *  1.键值对溢出的情况以及父子关系此处无需处理，后续可以在外部处理
   *  2.如果old_value不存在，返回-1
   *  3.return size 
   * 处理逻辑建议：
   *  1.通过old_value找到old_value所在的索引位置old_index
   *  2.如果old_index=-1,函数返回-1
   *  3.如果old_index<>-1，那么将old_index之后的元素(不含old_index)向后移动一位
   *  4.在old_index将新的键值对插入进来
   */
  INDEX_TEMPLATE_ARGUMENTS
  int B_PLUS_TREE_INTERNAL_PAGE_TYPE::InsertNodeAfter(const ValueType &old_value, const KeyType &new_key,
                                                      const ValueType &new_value) {
    //当底层元素分裂后，需要在父节点的当前底层元素索引（old_value）后添加新节点指向分裂后的新底层节点
    int old_index = ValueIndex(old_value);
    if (old_index != -1) {
      int i;
  		for (i = GetSize(); i > old_index+1; i--) {
        array_[i] = array_[i - 1];
      }
      array_[i].first = new_key; 
      array_[i].second  = new_value; 
  		IncreaseSize(1);
      return GetSize();
    }
  	return -1;
  
  }
  
  /*****************************************************************************
   * 内部结点分裂
   *****************************************************************************/
  /*
   *函数功能：
   * 移动this结点中一半（向上取整）的元素到一个新生成的recipient结点中
   *建议：
   *  1.优先实现CopyNFrom函数
   *  2.在内部调用CopyNFrom函数实现该功能
   *  3.一般用于当前结点中元素溢出时进行分裂，将多余元素移入新结点中。（请在函数外部进行父结点元素的更新）
   *  eg:
   *    this == r1,  recipient == r2
   *    r1->[<invalid, p0>, <1, p1>, <2, p2>, <3, p3>, <4, p4>] ----MoveHalfTo--> r2[]
   *    result: r1->[<invalid, p0>, <1, p1>],r2[<2, p2>, <3, p3>, <4, p4>]
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveHalfTo(BPlusTreeInternalPage *recipient,
                                                  BufferPoolManager *buffer_pool_manager) {
    int size = GetSize();
    int remain_size = size / 2;
    recipient->CopyNFrom(array_ + remain_size, size - remain_size, buffer_pool_manager);
    SetSize(remain_size);
    return;
  
  
  }
  
  /*
   * 函数功能：
   *  从item处开始，截取size个键值对并入到结点的尾部
   * 建议：
   *  1.由于该结点属于内部结点，结点中元素迁移后需要对子元素的ParentPageId进行更新，即对子结点进行fetch，更新后再unpin
   *  2.更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyNFrom(MappingType *items, int size, BufferPoolManager *buffer_pool_manager) {
  	//内部节点的索引指向了子元素结点，当迁移后这个关系仍不变
  	//但是由于内部节点一部分迁移到了新的结点，故这部分的子元素结点的父元素需要调整
  	//故需要把page从磁盘中取出，即bufferpool
    //例程：
    //将array_[i].second(Page_id)所对应的页取出来，并赋给指针page
    //Page *page = buffer_pool_manager->FetchPage(array_[i].second);
    // page->GetData()强转为BPlusTreePage
    //  BPlusTreePage *bp_tree_page = reinterpret_cast<BPlusTreePage *>(page->GetData());
    // bp_tree_page的父结点设置为本节点
    // bp_tree_page->SetParentPageId(GetPageId());
    // 更新完毕后再unpin
    // buffer_pool_manager->UnpinPage(array_[i].second, true);
    int size_ = GetSize();
    for (int i = size_; i < size_ + size; i++) {
      array_[i] = *items++;
      Page *page = buffer_pool_manager->FetchPage(array_[i].second);
      BPlusTreePage *bp_tree_page = reinterpret_cast<BPlusTreePage *>(page->GetData());
      bp_tree_page->SetParentPageId(GetPageId());
      buffer_pool_manager->UnpinPage(array_[i].second, true);
      IncreaseSize(1);
    }
  
  
  
  }
  
  /*****************************************************************************
   * 内部结点移除
   *****************************************************************************/
  /*
   * 函数功能：
   *  1.移除this结点中的index处的键值对
   * 建议：
   *  1.注意元素的移动
   *  2.更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::Remove(int index) {
    for (int i = index; i < GetSize() - 1; ++i) {
      array_[i] = array_[i + 1];
    }
    IncreaseSize(-1);
  }
  
  /* 使用情景：
   *  当根节点只有一个子节点时，可以将这个根节点删除，并将其子节点提升起来作为根节点
   * 函数功能：
   *  返回根结点含有的唯一元素ValueAt(0)
   * 建议：
   *  1.该函数只在AdjustRoot()(in b_plus_tree.cpp)中调用
   *  2.更新size
   */ 
  INDEX_TEMPLATE_ARGUMENTS
  ValueType B_PLUS_TREE_INTERNAL_PAGE_TYPE::RemoveAndReturnOnlyChild() { 
    IncreaseSize(-1);
    return ValueAt(0);
  }
  /*****************************************************************************
   * 内部结点合并
   *****************************************************************************/
  /*使用场景：
   *  当前节点删除 key 后，节点的数量小于 MinSize, 如果 sibling size 很少的情况下，
   *  不宜进行重分配，否则兄弟节点的 size 将小于MinSize，此时应考虑合并。当兄弟节点的 
   *  size 没有到达最大值时，当前节点的剩余键值对可以合并入该节点。
   *函数功能：
   *  合并this结点的元素至recipient结点中，即将this结点中的全部元素移至recipient结点的尾部
   *建议：
   *  1.this结点的变化影响了其子结点（子结点的父结点属性需要进行更新）
   *  2.更新recipient结点的size大小
   *  3.this结点的变化影响了其父结点（父结点中指向该结点的键值对需要被清除）,此操作在函数外进行，
   *    不需要在此处实现
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveAllTo(BPlusTreeInternalPage *recipient,
                                                 BufferPoolManager *buffer_pool_manager) {
  
  
    // the separation key from parent
  	//the separation key的value指向this结点，即this结点上元素的值均大于the separation key
  	//this结点的首元素无key值，无法直接合并到recipient，首元素所指向的值比the separation key大比一号元素小（即首元素的key实际上就是the separation key）
    int start = recipient->GetSize();
    page_id_t recipPageId = recipient->GetPageId();
    Page *page = buffer_pool_manager->FetchPage(GetParentPageId());
    assert(page != nullptr);
    BPlusTreeInternalPage *parent = reinterpret_cast<BPlusTreeInternalPage *>(page->GetData());
    int index = parent->ValueIndex(GetPageId());
    SetKeyAt(0,parent->KeyAt(index));
    buffer_pool_manager->UnpinPage(parent->GetPageId(), false);
    for (int i = 0; i < GetSize(); ++i) {
      recipient->array_[start + i].first = array_[i].first;
      recipient->array_[start + i].second = array_[i].second;
      auto childRawPage = buffer_pool_manager->FetchPage(array_[i].second);
      BPlusTreePage *childTreePage = reinterpret_cast<BPlusTreePage *>(childRawPage->GetData());
      childTreePage->SetParentPageId(recipPageId);
      buffer_pool_manager->UnpinPage(array_[i].second, true);
    }
    recipient->SetSize(start + GetSize());
    assert(recipient->GetSize() <= GetMaxSize());
    SetSize(0);
  }
  
  /*****************************************************************************
   * 重分配
   *****************************************************************************/
  /*使用场景：
   *  当前节点删除 key 后，节点的数量小于 MinSize,而如果 sibling size 很满的情况下，
   *  不宜进行merge，否则兄弟节 点的 size 将溢出，此时应考虑重分配。将满的sibling结点
   *  的首元素移到本节点，进行重分配。
   *
   * 函数功能：
   *  移动this结点的首元素至recipient结点的末尾
   * 建议：
   *  1.recipient调用CopyLastFrom函数实现节点更新
   *  2.this结点更新size
   *  3.由于this结点首元素变化，因此父结点中this结点的索引需要更新
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveFirstToEndOf(BPlusTreeInternalPage *recipient,
                                                        BufferPoolManager *buffer_pool_manager) {
  
   Page *page = buffer_pool_manager->FetchPage(GetParentPageId());
    assert(page != nullptr);
    BPlusTreeInternalPage *parent = reinterpret_cast<BPlusTreeInternalPage *>(page->GetData());
    int index = parent->ValueIndex(GetPageId());
    SetKeyAt(0, parent->KeyAt(index));
    MappingType pair{KeyAt(0), ValueAt(0)};
  
    IncreaseSize(-1);
  	//数组空间整体向前移动一个单位
    memmove(array_, array_ + 1, static_cast<size_t>(GetSize() * sizeof(MappingType)));
    recipient->CopyLastFrom(pair, buffer_pool_manager);
  
  	//当移动头元素后，有以下结点需要调整
  	//该结点由于头元素发生了变化（即无效元素改变），此时父结点指向该结点的元素key值需要调整，为新的无效元素的key值上移至该元素
    // update relavent key & value pair in its parent page.
    parent->SetKeyAt(parent->ValueIndex(GetPageId()), array_[0].first);
    buffer_pool_manager->UnpinPage(GetParentPageId(), true);
  	return;
  
  }
  
  /*
   * 函数功能：
   *  将pair元素添加到this结点的尾部
   * 建议：
   *  1.更新pair元素的父结点信息为this结点的PageId
   *  2.更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyLastFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager) {
    array_[GetSize()] = pair;
    IncreaseSize(1);
    page_id_t childPageId = pair.second;
    Page *page = buffer_pool_manager->FetchPage(childPageId);
    assert(page != nullptr);
    BPlusTreePage *child = reinterpret_cast<BPlusTreePage *>(page->GetData());
    child->SetParentPageId(GetPageId());
    buffer_pool_manager->UnpinPage(child->GetPageId(), true);
    return;
  
  
  }
  /*
   * 函数功能：
   *  移动this结点的尾部元素至recipient结点的头部
   * 建议：
   *  1.recipient调用CopyFirstFrom函数实现节点更新
   *  2.this结点更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::MoveLastToFrontOf(BPlusTreeInternalPage *recipient,
                                                         BufferPoolManager *buffer_pool_manager) {
  
    MappingType pair{KeyAt(GetSize() - 1), ValueAt(GetSize() - 1)};
    IncreaseSize(-1);
    recipient->CopyFirstFrom(pair, buffer_pool_manager);
    return;
  
  }
  /*
   * 函数功能：
   *  移动pair元素至recipient结点的首部
   * 建议：
   *  1.由于首元素变化，需要对父结点中的索引进行更新
   *  2.更新size
   *  3.更新pair元素的父结点信息
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_INTERNAL_PAGE_TYPE::CopyFirstFrom(const MappingType &pair, BufferPoolManager *buffer_pool_manager) {
  
    Page *page = buffer_pool_manager->FetchPage(GetParentPageId());
    assert(page != nullptr);
    BPlusTreeInternalPage *parent = reinterpret_cast<BPlusTreeInternalPage *>(page->GetData());
    int index = parent->ValueIndex(GetPageId());
    SetKeyAt(0, parent->KeyAt(index));
  
  	memmove(array_ + 1, array_, GetSize() * sizeof(MappingType));
    array_[0].first = pair.first;
    array_[0].second = pair.second;
    IncreaseSize(1);
    page_id_t childPageId = pair.second;
    page = buffer_pool_manager->FetchPage(childPageId);
    assert(page != nullptr);
    BPlusTreePage *child = reinterpret_cast<BPlusTreePage *>(page->GetData());
    child->SetParentPageId(GetPageId());
    buffer_pool_manager->UnpinPage(child->GetPageId(), true);
  
    parent->SetKeyAt(parent->ValueIndex(GetPageId()), array_[0].first);
    buffer_pool_manager->UnpinPage(GetParentPageId(), true);
    return;
  }
  
  template class BPlusTreeInternalPage<GenericKey<4>, page_id_t, GenericComparator<4>>;
  template class BPlusTreeInternalPage<GenericKey<8>, page_id_t, GenericComparator<8>>;
  template class BPlusTreeInternalPage<GenericKey<16>, page_id_t, GenericComparator<16>>;
  template class BPlusTreeInternalPage<GenericKey<32>, page_id_t, GenericComparator<32>>;
  template class BPlusTreeInternalPage<GenericKey<64>, page_id_t, GenericComparator<64>>;
  }
  
  ```

  

- 第3关：BPlusTreeLeafPage的设计

  #### BPlusTreeLeafPage 结构简述

  叶子页存储有序的m个键条目(key)和m个值条目(value)。 在实现中，值通常只能是用于定位实际元组存储位置的64位record_id。 叶子页与内部页在键/值对的数量上具有相同的限制，并且应该遵循相同的合并，重新分配和拆分操作。叶结点成员将在BPlusTreePage的基础上额外增加一个数组，用于存储记录信息以及next_page_id_存储相邻叶结点的索引。 一个Max_size为n的叶结点，可以存储n条记录，即该数组有如下结构：

  | KEY(0)+RecordID_ID(0) | KEY(1)+Record_ID(1) | ...  | KEY(n)+RecordID_ID(n) |
  | --------------------- | ------------------- | ---- | --------------------- |

  键在数组中维持有序排列。 参看BPlusTreeLeafPage的数据结构，注意 next_page_id_的位置

  ### 相关变量声明

  ```
  //BPlusTreeLeafPage中的记录数组
  MappingType array_[0];
  //索引键值对，叶子结点中为<Key,RID>，RID存储记录信息
  MappingType std::pair<KeyType, ValueType>
  //缓冲区对象，负责特定页的获取
  BufferPoolManager *buffer_pool_manager
  //比较器，负责键的比较
  KeyComparator &comparator
  ```

  ### 关卡内容

  请在b_plus_tree_leaf_page.cpp文件中实现下列函数：

  ```
    void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int max_size = LEAF_PAGE_SIZE);  
    page_id_t GetNextPageId() const;  
    void SetNextPageId(page_id_t next_page_id);  
    KeyType KeyAt(int index) const;  
    int KeyIndex(const KeyType &key, const KeyComparator &comparator) const;  const MappingType &GetItem(int index);  
    int Insert(const KeyType &key, const ValueType &value, const KeyComparator &comparator);  
    bool Lookup(const KeyType &key, ValueType *value, const KeyComparator &comparator) const;  
    int RemoveAndDeleteRecord(const KeyType &key, const KeyComparator &comparator);  
    void MoveHalfTo(BPlusTreeLeafPage *recipient, __attribute__((unused)) BufferPoolManager *buffer_pool_manager);  
    void MoveAllTo(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager);  
    void MoveFirstToEndOf(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager);  
    void MoveLastToFrontOf(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager);  
    void CopyNFrom(MappingType *items, int size);  void CopyLastFrom(const MappingType &item);  
    void CopyFirstFrom(const MappingType &item,BufferPoolManager *buffer_pool_manager);
  ```

  code:

  ```
  #pragma once
  
  #include <utility>
  #include <vector>
  
  #include "storage/page/b_plus_tree_page.h"
  
  namespace bustub {
  
  #define B_PLUS_TREE_LEAF_PAGE_TYPE BPlusTreeLeafPage<KeyType, ValueType, KeyComparator>
  #define LEAF_PAGE_HEADER_SIZE 28
  #define LEAF_PAGE_SIZE ((PAGE_SIZE - LEAF_PAGE_HEADER_SIZE) / (sizeof(MappingType))) - 1
  
  INDEX_TEMPLATE_ARGUMENTS
  class BPlusTreeLeafPage : public BPlusTreePage {
   public:
  
    void Init(page_id_t page_id, page_id_t parent_id = INVALID_PAGE_ID, int max_size = LEAF_PAGE_SIZE);
    page_id_t GetNextPageId() const;
    void SetNextPageId(page_id_t next_page_id);
    KeyType KeyAt(int index) const;
    int KeyIndex(const KeyType &key, const KeyComparator &comparator) const;
    const MappingType &GetItem(int index);
  
    int Insert(const KeyType &key, const ValueType &value, const KeyComparator &comparator);
    bool Lookup(const KeyType &key, ValueType *value, const KeyComparator &comparator) const;
    int RemoveAndDeleteRecord(const KeyType &key, const KeyComparator &comparator);
  
    void MoveHalfTo(BPlusTreeLeafPage *recipient, __attribute__((unused)) BufferPoolManager *buffer_pool_manager);
    void MoveAllTo(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager);
    void MoveFirstToEndOf(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager);
    void MoveLastToFrontOf(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager);
   private:
    void CopyNFrom(MappingType *items, int size);
    void CopyLastFrom(const MappingType &item);
    void CopyFirstFrom(const MappingType &item,BufferPoolManager *buffer_pool_manager);
    //B+树叶结点依序访问，最后一个叶结点的next_page_id_是INVALID_PAGE_ID
    page_id_t next_page_id_;
    MappingType array_[0];
  };
  }
  
  
  ```

  ```
  #include <sstream>
  
  #include "common/exception.h"
  #include "common/rid.h"
  #include "storage/page/b_plus_tree_leaf_page.h"
  #include "storage/page/b_plus_tree_internal_page.h"
  
  namespace bustub {
  
  /**
   * 函数功能：
   *  初始化this页，包括page type,size,page id,parent id and max page size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::Init(page_id_t page_id, page_id_t parent_id, int max_size) {
    SetPageType(IndexPageType::LEAF_PAGE);
    SetSize(0);
    SetPageId(page_id);
    SetParentPageId(parent_id);
    SetMaxSize(max_size);
    SetNextPageId(INVALID_PAGE_ID);
    return;
  }
  
  /**
   * 函数功能：
   *  获取相邻叶子节点的page_id
   * 建议：
   *  next_page_id_属性
   */
  INDEX_TEMPLATE_ARGUMENTS
  page_id_t B_PLUS_TREE_LEAF_PAGE_TYPE::GetNextPageId() const {return next_page_id_;}
  /**
   * 函数功能：
   *  设置相邻叶子节点的page_id
   * 建议：
   *  next_page_id_属性
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::SetNextPageId(page_id_t next_page_id) { 
    next_page_id_=next_page_id;
    return;
   }
  
  /**
   * 函数功能：
   *  在key值有序排列的数组中，找到特定key值对应的index
   * 建议：
   *  1.如果当前节点尚不存在key值(size==0)，则可以返回首结点
   *  2.如果key值不存在，返回应插入的index的位置
   */
  INDEX_TEMPLATE_ARGUMENTS
  int B_PLUS_TREE_LEAF_PAGE_TYPE::KeyIndex(const KeyType &key, const KeyComparator &comparator) const {
    //如果当前节点尚不存在key值，则可以直接插入到第一个结点
  	if (GetSize() == 0) return 0;
    int low = 0;
    int high = GetSize() - 1;
    int mid;
    while(low <= high) {
      mid = (low + high) / 2;
      if (comparator(array_[mid].first, key) < 0)
        low = mid + 1;
      else if (comparator(array_[mid].first, key) > 0)
        high = mid - 1;
      else
        return mid;
    }
    return low;
  }
  
  /**
   * 函数功能：
   *  返回index处的key值
   * 建议：
   *  1.数组中元素为pair，first为key，second为RID
   */
  INDEX_TEMPLATE_ARGUMENTS
  KeyType B_PLUS_TREE_LEAF_PAGE_TYPE::KeyAt(int index) const {
    return array_[index].first;
  }
  
  
  /**
   * 函数功能：
   *  返回index处的元素
   * 建议：
   *  1.数组中元素为pair，first为key，second为RID
   */
  INDEX_TEMPLATE_ARGUMENTS
  const MappingType &B_PLUS_TREE_LEAF_PAGE_TYPE::GetItem(int index) {
    return array_[index];
  }
  
  /*****************************************************************************
   *插入
   *****************************************************************************/
  /**
   * 函数功能：
   *  在保证有序地情况下插入新的键值对
   * 建议：
   *  1.元素溢出的情况无需处理，后续可以在外部处理
   *  2.当size为0时插入到数组头部
   *  3.更新size并返回当前size大小
   */
  INDEX_TEMPLATE_ARGUMENTS
  int B_PLUS_TREE_LEAF_PAGE_TYPE::Insert(const KeyType &key, const ValueType &value, const KeyComparator &comparator) {
  
    int p=KeyIndex(key,comparator);
    int i;
    for(i=GetSize();i>p;i--)
      array_[i]=array_[i-1];
    array_[p].first=key;
    array_[p].second=value;
    IncreaseSize(1);
    return GetSize();
  }
  
  /*****************************************************************************
   * 分裂
   *****************************************************************************/
  /**
   *函数功能：
   * 移动this结点中一半（向上取整）的元素到一个新生成的recipient结点中
   *建议：
   *  1.优先实现CopyNFrom函数
   *  2.在内部调用CopyNFrom函数实现该功能
   *  3.更新this结点和recipient结点的NextPageId属性，注意recipient结点显然是this结点后继结点
   *  eg:
   *      this == r1,  recipient == r2
   *      r1->[<0, r0>, <1, r1>, <2, r2>, <3, r3>, <4, r4>] ----MoveHalfTo--> r2[]
   *      result: r1->[<0, r0>, <1, r1>] ---> r2[<2, r2>, <3, r3>, <4, r4>]
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveHalfTo(BPlusTreeLeafPage *recipient,
                                              __attribute__((unused)) BufferPoolManager *buffer_pool_manager) {
  
      int size=GetSize();
      int remain=size/2;
      recipient->CopyNFrom(array_+remain,size-remain);
      SetSize(remain);
      recipient->SetNextPageId(GetNextPageId());
      SetNextPageId(recipient->GetPageId());
      return;
  }
  
  /**
   * 函数功能：从item处开始，截取size个键值对并入到结点的尾部
   * 建议：
   *  1.更新size大小
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::CopyNFrom(MappingType *items, int size) {
  
    int num=GetSize();
    for(int i=num;i<num+size;i++)
    {
      array_[i]=*items;
      items++;
      IncreaseSize(1);
    }
  
  
  
  }
  
  /*****************************************************************************
   * 查找
   *****************************************************************************/
  /**
   * 函数功能：
   *  在key值有序排列的数组中，找到特定key值对应的value
   * 建议：
   *  1.可以调用KeyIndex()函数
   *  2.如果key值存在，存储key对应的value值，返回true
   *  3.如果key值不存在，直接返回false
   *  4.使用comparator进行key值的比较
   */
  INDEX_TEMPLATE_ARGUMENTS
  bool B_PLUS_TREE_LEAF_PAGE_TYPE::Lookup(const KeyType &key, ValueType *value, const KeyComparator &comparator) const {
  
    int p=KeyIndex(key,comparator);
    if(comparator(array_[p].first,key)==0&&p<GetSize())
    {
      *value=array_[p].second;
      return true;
    }
    return false;
  
  
  }
  
  /*****************************************************************************
   * 移除
   *****************************************************************************/
  /**
   * 函数功能：
   *  1.移除this结点中的index元素
   * 建议：
   *  1.当key不存在时，直接返回当前size
   *  1.注意元素的移动
   *  2.更新并返回size
   */
  INDEX_TEMPLATE_ARGUMENTS
  int B_PLUS_TREE_LEAF_PAGE_TYPE::RemoveAndDeleteRecord(const KeyType &key, const KeyComparator &comparator) {
  
    int p=KeyIndex(key,comparator);
    if(comparator(array_[p].first,key)==0&&p<GetSize())
    {
      for(int i=p;i<GetSize()-1;i++)
      {
          array_[i]=array_[i+1];
      }
      IncreaseSize(-1);
    }
    return GetSize();
  
  
  }
  
  /*****************************************************************************
   * 合并
   *****************************************************************************/
  /**
   * 函数功能：
   *  合并this结点的元素至recipient结点中，即将this结点中的全部元素移至recipient结点的尾部
   * 建议：
   *  1.this结点显然是recipient结点后继叶结点，因此需要更新recipient结点的NextPageId为this
   *     结点的nextPageId。
   *  2.更新size大小
   *  3.this结点内容全部移动至sibling recipient结点，而this结点的父节点内容需要删除，但不用
   *    在本函数中实现。
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveAllTo(BPlusTreeLeafPage *recipient, BufferPoolManager *buffer_pool_manager) { 
    int n=recipient->GetSize();
    for(int i=0;i<GetSize();i++)
    {
      recipient->array_[n+i]=array_[i];
      recipient->IncreaseSize(1);
    }
    recipient->SetNextPageId(GetNextPageId());
    SetSize(0);
  
  
  
  
  }
  
  /*****************************************************************************
   * 重分配
   *****************************************************************************/
  /**
   * 函数功能：
   *  移动this结点的首元素至recipient结点的末尾
   * 建议：
   *  1.recipient调用CopyLastFrom函数实现节点更新
   *  2.this结点更新size
   *  3.由于this结点首元素发生变化，因此父结点中this结点的索引key值需要更新
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveFirstToEndOf(BPlusTreeLeafPage *recipient,
                                                    BufferPoolManager *buffer_pool_manager) {
  
    MappingType pair = GetItem(0);
    recipient->CopyLastFrom(pair);
    memmove(array_, array_ + 1, static_cast<size_t> (sizeof(MappingType) * (GetSize() - 1)));
    IncreaseSize(-1);
    Page *page = buffer_pool_manager->FetchPage(GetParentPageId());
    B_PLUS_TREE_INTERNAL_PAGE *parent = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(page->GetData());
    parent->SetKeyAt(parent->ValueIndex(GetPageId()), array_[0].first);
    buffer_pool_manager->UnpinPage(GetParentPageId(), true);
  
  
  }
  
  /**
   * 函数功能：
   *  将pair元素添加到this结点的尾部
   * 建议：
   *  1.更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::CopyLastFrom(const MappingType &item) {
  
    array_[GetSize()]=item;
    IncreaseSize(1);
  
  }
  
  /**
   * 函数功能：
   *  移动this结点的尾部元素至recipient结点的头部
   * 建议：
   *  1.recipient调用CopyFirstFrom函数实现节点更新
   *  2.this结点更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::MoveLastToFrontOf(BPlusTreeLeafPage *recipient,
                                                     BufferPoolManager *buffer_pool_manager) {
  
      MappingType pair = GetItem(GetSize() - 1);
      IncreaseSize(-1);
      recipient->CopyFirstFrom(pair,buffer_pool_manager);
  
  }
  
  /**
   * 函数功能：
   *  移动pair元素至recipient结点的首部
   * 建议：
   *  1.由于结点首元素发生变化，父结点中this结点的索引key值需要更新
   *  2.更新size
   */
  INDEX_TEMPLATE_ARGUMENTS
  void B_PLUS_TREE_LEAF_PAGE_TYPE::CopyFirstFrom(const MappingType &item,
                                                  BufferPoolManager *buffer_pool_manager) {
  
    memmove(array_ + 1, array_, GetSize() * sizeof(MappingType));
    IncreaseSize(1);
    array_[0] = item;
  
    Page *page = buffer_pool_manager->FetchPage(GetParentPageId());
    B_PLUS_TREE_INTERNAL_PAGE *parent = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(page->GetData());
    parent->SetKeyAt(parent->ValueIndex(GetPageId()), array_[0].first);
    buffer_pool_manager->UnpinPage(GetParentPageId(), true);
  
  }
  
  template class BPlusTreeLeafPage<GenericKey<4>, RID, GenericComparator<4>>;
  template class BPlusTreeLeafPage<GenericKey<8>, RID, GenericComparator<8>>;
  template class BPlusTreeLeafPage<GenericKey<16>, RID, GenericComparator<16>>;
  template class BPlusTreeLeafPage<GenericKey<32>, RID, GenericComparator<32>>;
  template class BPlusTreeLeafPage<GenericKey<64>, RID, GenericComparator<64>>;
  }  // namespace bustub
  
  ```
  
  
  
- 第4关：B+树索引：Insert

  #### BPlusTree简述

  出于难度考虑，目前B+树索引仅存在Unique Key，即索引中存储的key值不重复。 一颗完整的B+树由内部结点和叶结点组成，随着记录的插入，结点不断分裂增加，但仍需保持B+树的完整性和一致性。

  #### IndexIterator简述

  作为BPlusTree的迭代器，需要实现对B+树存储记录的有序遍历，即自增，末尾判断等功能。

  #### 任务和测试说明

  ​	在完成B+树相关数据结构的设计后，可以开始B+树类的整体功能实现，这一关卡，需要完成**B+树索引的查找以及插入**功能，并实现**B+树记录迭代器**。  

  ​	BPlusTree即B+树类，一颗完整的B+树从最初的空树，随着记录的插入，叶子节点不断分裂增加并产生用于索引的内部节点，逐渐生成一个完整的B+树，但在整个过程中需保持B+树的完整性和一致性。  

  ​	在本关卡中，**B+树仅对外暴露Insert以及GetValue接口**，即向B+树中插入记录和定位记录。当有记录插入时，从根节点进入B+树，定位叶子节点并插入该记录。插入后判断内部记录是否超过最大值，如果超过，对叶子节点进行分裂，内部记录对半分离，产生新叶子节点，插入到叶子节点链表中。同时，在父节点中插入新叶子节点索引，即进行递归插入，直至不再有分裂。在充分理解B+树的插入过程后，根据流程自上而下定义多个私有函数承载不同的子功能，并将待实现函数的功能以及整个流程中的函数调用关系和条件做明确注释说明，引导学生思考并完成局部功能，最后整合为插入功能。  在插入功能完成后，已经可以实现B+树的生长。因此，对B+树存储信息的查找和迭代也是不可缺少的，查找功能即B+树的记录的定位，从根节点进入，通过内部节点的索引信息不断向下遍历，直至对应的叶子节点，即可查找特定的记录信息。同时，结合查找功能，B+树需要生成自身记录的迭代器，迭代器由当前叶子节点指针和元素下表组成，通过实现对++运算符的重载，完成迭代器在叶子节点链表中的遍历，并实现末尾判定函数以结束遍历。  针对上述功能，设计测试流程以判断BPlusTree的插入功能是否达到预期结果。在该关卡中，BPlusTree可以作为一个功能完备的类，可以独立进行测试，为了复现插入功能中可能出现的各种情况，并全面覆盖评测功能函数中不同条件下应有的逻辑处理路径，需要设置针对性的测试数据和测试流程，以观察对象实例的变化过程是否符合预期。  测试流程分为三个阶段，代表了B+树生长过程中的三个阶段，三个阶段均验证插入功能和查找功能，同时穿插B+树迭代器遍历数据进行数据完整性验证。 B+树由无到有，深度为1。B+树初始化，指定缓冲区管理器以及当前阶数，从而方便后续进行树结构正确性验证，进入第一阶段，此时B+树为空，在插入数据后观察根节点是否如期生成，数据是否完整，同时迭代器可否正常工作。   B+树第一次分裂，根节点更新，深度由1到2。插入数据使B+树进入分裂状态节点，生成2层B+树，由于阶数与插入数据均确定，此时B+树的内部结构和数据应符合预期要求。在这里实现B+树的打印功能以辅助评测流程的进行，将此时的树打印出来，与预期结果对比进行验证。  B+树开始不断插入数据，以大量数据覆盖插入过程中功能函数的所有路径，验证插入功能的健壮性。在这个阶段，不仅需要校验功能的完整性、数据的准确性，还会对内存管理进行验证，由于大量数据的插入，必然会出现缓冲区满和页面替换的情况，如果没有处理好页的获取与释放，就会导致缓冲区内存溢出，程序出错，因此也需要注意对缓冲区处理的评测。

  ### 部分变量声明

  ```
  //内部结点,叶结点,迭代器定义时可直接使用以下类型声明
  #define B_PLUS_TREE_LEAF_PAGE_TYPE BPlusTreeLeafPage<KeyType, ValueType, KeyComparator>
  #define B_PLUS_TREE_INTERNAL_PAGE BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator>
  #define INDEXITERATOR_TYPE IndexIterator<KeyType, ValueType, KeyComparator>
  //头页，用于存储metadata，比如记录索引根结点，表信息等等
  HeaderPage *header_page
  //缓冲区对象，负责特定页的获取
  BufferPoolManager *buffer_pool_manager
  ```

  ### 关卡内容

  请在b_plus_tree.cpp文件中实现下列函数：

  ```
  bool IsEmpty() const;
  bool Insert(const KeyType &key, const ValueType &value);
  bool GetValue(const KeyType &key, std::vector<ValueType> *result);
  Page *FindLeafPage(const KeyType &key, bool leftMost = false);
  void StartNewTree(const KeyType &key, const ValueType &value);
  bool InsertIntoLeaf(const KeyType &key, const ValueType &value);
  void InsertIntoParent(BPlusTreePage *old_node, const KeyType &key, BPlusTreePage *new_node);
  template <typename N>  N *Split(N *node);
  void UpdateRootPageId(int insert_record = 0);
  //index_iteratorINDEXITERATOR_TYPE Begin();
  INDEXITERATOR_TYPE Begin(const KeyType &key);
  INDEXITERATOR_TYPE End();
  ```

  请在index_iterator.cpp文件中实现下列函数：

  ```
  bool IsEnd();
  const MappingType &operator*();
  IndexIterator &operator++();
  ```

  code

  ```
  //b_plus_tree.cpp
  
  #include "storage/index/b_plus_tree.h"
  #include "common/exception.h"
  #include "common/rid.h"
  #include "storage/page/header_page.h"
  #include <iostream>
  #include <string>
  
  namespace bustub
  {
    INDEX_TEMPLATE_ARGUMENTS
    BPLUSTREE_TYPE::BPlusTree(std::string name, BufferPoolManager *buffer_pool_manager, const KeyComparator &comparator,
                              int leaf_max_size, int internal_max_size)
        : index_name_(std::move(name)),
          root_page_id_(INVALID_PAGE_ID),
          buffer_pool_manager_(buffer_pool_manager),
          comparator_(comparator),
          leaf_max_size_(leaf_max_size),
          internal_max_size_(internal_max_size) {}
  
    /*
     * 函数功能：
     *  判断B+树是否为空
     * 建议：
     *  B+树初始化后root_page_id_为INVALID_PAGE_ID
     */
    INDEX_TEMPLATE_ARGUMENTS
    bool BPLUSTREE_TYPE::IsEmpty() const
    {
      //之前的page类型均为结点，现在该类型表示整个B+树
      return root_page_id_ == INVALID_PAGE_ID;
    }
    /*****************************************************************************
     * 查找
     *****************************************************************************/
    /*
     * 函数功能：
     *  在B+树中，查找key值对应的记录
     *  如果存在则返回true，并将记录push到result中
     *  如果不存在则返回false
     * 建议：
     *  1.通过调用FindLeafPage(key)函数寻找key值所在叶结点
     *  2.当前叶子结点中不存在该key值，返回false
     *  3.当叶子结点不再使用后，需要及时unpin释放，避免缓冲区内存泄露
     *  4.注意利用
     *   B_PLUS_TREE_LEAF_PAGE_TYPE *leafPage = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE*>
     *                                         (page->GetData());
     */
    INDEX_TEMPLATE_ARGUMENTS
    bool BPLUSTREE_TYPE::GetValue(const KeyType &key, std::vector<ValueType> *result)
    {
      // latch锁，本次实验不考虑
      std::lock_guard<std::mutex> lock(latch_);
      Page *page = FindLeafPage(key);
      if (page == nullptr)
        return false;
      else
      {
        B_PLUS_TREE_LEAF_PAGE_TYPE *leafPage = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page->GetData());
        ValueType value;
        int flag = leafPage->Lookup(key, &value, comparator_);
        if (flag)
        {
          result->push_back(value);
          buffer_pool_manager_->UnpinPage(leafPage->GetPageId(), false);
          return true;
        }
        else
        {
          buffer_pool_manager_->UnpinPage(leafPage->GetPageId(), false);
          return false;
        }
      }
    }
  
    /*
     * 函数功能：
     *  在B+树中，查找key值应在的叶结点
     *  当leftMost为true时，直接返回最左叶结点（用于遍历输出索引记录）
     * 建议：
     *  1.当B+树空时直接返回空指针
     *  2.通过buffer_pool_manager_->FetchPage(page_id)从磁盘中读入特定Page
     *  3.当特定page不再需要时，用buffer_pool_manager_->UnpinPage(page_id, is_dirty)解锁page，不再占用缓冲区
     *  3.不断向下搜索，直至目标叶子结点
     */
    INDEX_TEMPLATE_ARGUMENTS
    Page *BPLUSTREE_TYPE::FindLeafPage(const KeyType &key, bool leftMost)
    {
      if (IsEmpty())
        return nullptr;
      Page *page = buffer_pool_manager_->FetchPage(root_page_id_);
      BPlusTreePage *treePage = reinterpret_cast<BPlusTreePage *>(page->GetData());
      if (nullptr == treePage)
        return nullptr;
      page_id_t cur;
      for (page_id_t i = root_page_id_; !treePage->IsLeafPage();)
      {
        B_PLUS_TREE_INTERNAL_PAGE *internalPage = static_cast<B_PLUS_TREE_INTERNAL_PAGE *>(treePage);
        if (leftMost)
          cur = internalPage->ValueAt(0);
        else
          cur = internalPage->Lookup(key, comparator_);
        buffer_pool_manager_->UnpinPage(i, false);
        i = cur;
        page = buffer_pool_manager_->FetchPage(i);
        treePage = reinterpret_cast<BPlusTreePage *>(page->GetData());
      }
      return page;
    }
  
    /*****************************************************************************
     * 插入
     *****************************************************************************/
    /*
     * 函数功能：
     *  向B+树中插入key以及对应的value，成功返回true，失败则返回false
     * 建议：
     *  1.判断B+树是否为空，为空时调用StartNewTree函数处理
     *  2.若非空，则调用InsertIntoLeaf函数正常插入记录
     */
    INDEX_TEMPLATE_ARGUMENTS
    bool BPLUSTREE_TYPE::Insert(const KeyType &key, const ValueType &value)
    {
      std::lock_guard<std::mutex> lock(latch_);
      if (IsEmpty())
      {
        StartNewTree(key, value);
        return true;
      }
      else
        return InsertIntoLeaf(key, value);
    }
    /*
     * 函数功能：
     *  当B+树为空时插入记录时，该函数负责生成一个新B+树并初始化相关配置
     * 建议：
     *  1.根结点此时应为叶结点
     *  2.调用UpdateRootPageId(rootPageID)更新header_page文件中的根结点记录 //UpdateRootPageId无需实现
     *  3.及时unpin不再使用的page，避免缓冲区内存泄漏，注意是否为脏页
     */
    INDEX_TEMPLATE_ARGUMENTS
    void BPLUSTREE_TYPE::StartNewTree(const KeyType &key, const ValueType &value)
    {
      page_id_t root_page_id;
      Page *page = buffer_pool_manager_->NewPage(&root_page_id);
      if (page == nullptr)
        return;
      B_PLUS_TREE_LEAF_PAGE_TYPE *root = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page->GetData());
      root->Init(root_page_id, INVALID_PAGE_ID);
      root_page_id_ = root_page_id;
      UpdateRootPageId(root_page_id_);
      root->Insert(key, value, comparator_);
      buffer_pool_manager_->UnpinPage(root_page_id_, true);
    }
  
    /*
     * 函数功能：
     *  当B+树根结点发生变化时，调用该函数在header_page中对根结点ID进行更新
     *  header_pagez中存放元数据，当B+树根节点发生变化时一定要修改header_page
     */
    INDEX_TEMPLATE_ARGUMENTS
    void BPLUSTREE_TYPE::UpdateRootPageId(int insert_record)
    {
      HeaderPage *header_page = static_cast<HeaderPage *>(buffer_pool_manager_->FetchPage(HEADER_PAGE_ID));
      if (insert_record != 0)
      {
        // create a new record<index_name + root_page_id> in header_page
        header_page->InsertRecord(index_name_, root_page_id_);
      }
      else
      {
        // update root_page_id in header_page
        header_page->UpdateRecord(index_name_, root_page_id_);
      }
      buffer_pool_manager_->UnpinPage(HEADER_PAGE_ID, true);
    }
  
    /*
     * 函数功能：
     *  在正确的叶结点插入key以及对应的value，成功返回true，失败返回false
     * 建议：
     *  1.找到key值应在的叶结点
     *  2.key值若已存在，直接返回false(为了便于实现，当前仅支持unique key)
     *  3.插入后需判断结点元素是否超过max_size,并调用Split()和InsertIntoParent()进行后续处理
     *  4.注意unpinPage，避免缓冲区内存泄露
     */
    INDEX_TEMPLATE_ARGUMENTS
    bool BPLUSTREE_TYPE::InsertIntoLeaf(const KeyType &key, const ValueType &value)
    {
      //每次插入之后进行判断，是否已经超过最大值，选择直接进行分裂
      //由于MAXSIZE后还留有一个空白结点，这样可以保证插入结点而不会导致数据越界
      //这样就可以先插入，再分裂结点，避免了需要先分裂腾出空间，再插入其中一个的复杂操作
      Page *page = FindLeafPage(key);
      B_PLUS_TREE_LEAF_PAGE_TYPE *leafPage = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page->GetData());
      ValueType foundValue;
      int flag = leafPage->Lookup(key, &foundValue, comparator_);
      if (flag)
      {
        buffer_pool_manager_->UnpinPage(leafPage->GetPageId(), false);
        return false;
      }
      leafPage->Insert(key, value, comparator_);
      if (leafPage->GetSize() > leaf_max_size_)
      {
        B_PLUS_TREE_LEAF_PAGE_TYPE *splitLeafPage = Split(leafPage);
        InsertIntoParent(leafPage, splitLeafPage->KeyAt(0), splitLeafPage);
      }
      buffer_pool_manager_->UnpinPage(leafPage->GetPageId(), false);
      return true;
    }
    /*
     * 函数功能：
     *  分裂输入的结点(叶结点or内部结点)，返回新生成的结点
     * 建议：
     *  1.生成相同类型的新结点并初始化
     *  2.调用MoveHalfTo()进行结点的分裂
     */
    INDEX_TEMPLATE_ARGUMENTS
    template <typename N>
    N *BPLUSTREE_TYPE::Split(N *node)
    {
      page_id_t split_page_id;
      Page *split_page = buffer_pool_manager_->NewPage(&split_page_id);
      N *split_tree_page = reinterpret_cast<N *>(split_page->GetData());
      split_tree_page->Init(split_page_id, node->GetParentPageId());
      node->MoveHalfTo(split_tree_page, buffer_pool_manager_);
      return split_tree_page;
    }
  
    /*
     * 函数功能：
     *  当生成新结点后，在其父结点中插入正确的索引
     *  @param   old_node      分裂过的原结点
     *  @param   key      新索引的key值
     *  @param   new_node      分裂后生成的新结点
     * 建议：
     *  1.若为根结点分裂，即不存在父点时，应构造新根结点，并调用PopulateNewRoot快速添加对原根结点及分裂结点的索引
     *  2.调用UpdateRootPageId更新rootPageID
     *  3.若为内部结点分裂，在父节点中插入新元素后，若超过max_size,调用Split()和InsertIntoParent()进行
     *  4.更新ParentPageId
     *  5.注意unpinPage，避免缓冲区内存泄露
     */
    INDEX_TEMPLATE_ARGUMENTS
    void BPLUSTREE_TYPE::InsertIntoParent(BPlusTreePage *old_node, const KeyType &key, BPlusTreePage *new_node)
    {
      page_id_t parentId = old_node->GetParentPageId();
      if (parentId == INVALID_PAGE_ID)
      {
        //此时说明是根结点，无父结点存在，需重新生成根结点
        Page *new_page = buffer_pool_manager_->NewPage(&root_page_id_);
        B_PLUS_TREE_INTERNAL_PAGE *new_root = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(new_page->GetData());
        new_root->Init(root_page_id_, INVALID_PAGE_ID);
        new_root->PopulateNewRoot(old_node->GetPageId(), key, new_node->GetPageId());
        old_node->SetParentPageId(root_page_id_);
        new_node->SetParentPageId(root_page_id_);
        UpdateRootPageId();
        buffer_pool_manager_->UnpinPage(new_node->GetPageId(), true);
        buffer_pool_manager_->UnpinPage(new_root->GetPageId(), true);
      }
      else
      {
        Page *page = buffer_pool_manager_->FetchPage(parentId);
        B_PLUS_TREE_INTERNAL_PAGE *parent_page = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(page->GetData());
        new_node->SetParentPageId(parentId);
        parent_page->InsertNodeAfter(old_node->GetPageId(), key, new_node->GetPageId());
        if (parent_page->GetSize() > leaf_max_size_)
        {
          B_PLUS_TREE_INTERNAL_PAGE *splitLeafPage = Split(parent_page);
          InsertIntoParent(parent_page, splitLeafPage->KeyAt(0), splitLeafPage);
        }
        buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), true);
        buffer_pool_manager_->UnpinPage(new_node->GetPageId(), true);
      }
    }
  
    /*
     * 函数功能：
     *  返回指向B+树首个记录的迭代器
     * 建议：
     *  1.优先实现index_iterator.cpp文件
     *  2.调用FindLeafPage函数找到最左叶子结点，迭代器指向B+树首个记录
     */
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE BPLUSTREE_TYPE::Begin()
    {
      KeyType _;
      Page *page = FindLeafPage(_, true);
      B_PLUS_TREE_LEAF_PAGE_TYPE *start_leaf = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page->GetData());
      return INDEXITERATOR_TYPE(start_leaf, 0, buffer_pool_manager_);
    }
  
    /*
     * 函数功能：
     *  返回指向B+树特定key值记录的迭代器
     * 建议：
     *  1.优先实现index_iterator.cpp文件
     *  2.调用FindLeafPage函数找到key值所在叶子结点，迭代器指向该记录(或最近记录)
     */
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE BPLUSTREE_TYPE::Begin(const KeyType &key)
    {
      Page *page = FindLeafPage(key, false);
      B_PLUS_TREE_LEAF_PAGE_TYPE *start_leaf = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page->GetData());
      if (page == nullptr)
      {
        return INDEXITERATOR_TYPE(start_leaf, 0, buffer_pool_manager_);
      }
      int idx = start_leaf->KeyIndex(key, comparator_);
      return INDEXITERATOR_TYPE(start_leaf, idx, buffer_pool_manager_);
    }
  
    /*
     * 函数功能：
     *  返回IsEnd状态的B+树记录迭代器
     */
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE BPLUSTREE_TYPE::End() { return INDEXITERATOR_TYPE(nullptr, 0, buffer_pool_manager_); }
  
    template class BPlusTree<GenericKey<4>, RID, GenericComparator<4>>;
    template class BPlusTree<GenericKey<8>, RID, GenericComparator<8>>;
    template class BPlusTree<GenericKey<16>, RID, GenericComparator<16>>;
    template class BPlusTree<GenericKey<32>, RID, GenericComparator<32>>;
    template class BPlusTree<GenericKey<64>, RID, GenericComparator<64>>;
  
  } // namespace bustub
  
  
  //index_iterator.cpp
  #include "storage/index/index_iterator.h"
  #include <cassert>
  
  namespace bustub
  {
  
    /*
     * 迭代器的作用：
     *    方便程序访问每个叶结点中每个键值对元素，其成员变量index指向当前访问
     * 的叶结点内的键值对元素的索引号（键值对索引按照键值依序存储）,成员变量leaf_是
     * 一个指针，指向当前访问的叶结点。eg.
     *    leaf_->[<0, r0>, <1, r1>, <2, r2>, <3, r3>, <4, r4>]
     *                    index
     */
  
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE::IndexIterator(B_PLUS_TREE_LEAF_PAGE_TYPE *leaf, int index, BufferPoolManager *bufferPoolManager)
        : index_(index), leaf_(leaf), bufferPoolManager_(bufferPoolManager) {}
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE::IndexIterator() = default;
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE::~IndexIterator()
    {
      if (leaf_ != nullptr)
      {
        bufferPoolManager_->UnpinPage(leaf_->GetPageId(), false);
      }
    }
    /*
     * 函数功能：
     *  判断迭代器是否已经将叶结点全部迭代
     */
    INDEX_TEMPLATE_ARGUMENTS
    bool INDEXITERATOR_TYPE::IsEnd()
    {
      //有可能处于末尾，也有可能是空
      if (leaf_ == nullptr)
        return true;
      if (leaf_->GetSize() <= index_)
        return true;
      return false;
    }
    /*
     * 函数功能：
     *  返回迭代器在当前页的中指向的具体键值对
     */
    INDEX_TEMPLATE_ARGUMENTS
    const MappingType &INDEXITERATOR_TYPE::operator*()
    {
      return leaf_->GetItem(index_);
    }
  
    /*
     * 函数功能：
     *  迭代器移动至下一个记录(实现迭代器顺序遍历B+树记录的功能)，返回当前迭代器
     * 建议：
     *  1.利用NextPageId属性实现跨结点遍历
     *  2.当记录遍历至(NextPageId == INVALID_PAGE_ID),即IsEnd()返回true
     *  3.当叶子结点不再使用后，需要及时unpin释放，避免缓冲区内存泄露
     *  4.当index+1>leaf_->GetSize()时，要通过GetNextPageId（）跳转到下一页
     *  5.如果下一页是INVALID_PAGE_ID，
            只需要将 leaf_ = nullptr;
                     index_ = 0;
                     return *this;
          如果下一页不是INVALID_PAGE_ID
             bufferPoolManager_->UnpinPage(leaf_->GetPageId(), false);
             Page *page = bufferPoolManager_->FetchPage(next);
             leaf_ = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page);
             index_ = 0;
        6.当index+1<leaf_->GetSize()时，   index++,  return *this;
     */
    INDEX_TEMPLATE_ARGUMENTS
    INDEXITERATOR_TYPE &INDEXITERATOR_TYPE::operator++()
    {
      //该迭代器是叶子节点的迭代器，B+树的叶子节点之间相互连接，以实现顺序遍历的特性
      //故此迭代器应该可以在不同的结点间移动
      if ((index_ + 1) < leaf_->GetSize())
      {
        index_++;
        return *this;
      }
      else
      {
        page_id_t nextPageId = leaf_->GetNextPageId();
        if (nextPageId == INVALID_PAGE_ID)
        {
          bufferPoolManager_->UnpinPage(leaf_->GetPageId(), false);
          leaf_ = nullptr, index_ = 0;
          return *this;
        }
        else
        {
          bufferPoolManager_->UnpinPage(leaf_->GetPageId(), false);
          Page *page = bufferPoolManager_->FetchPage(nextPageId);
          leaf_ = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page);
          index_ = 0;
          return *this;
        }
      }
    }
  
    template class IndexIterator<GenericKey<4>, RID, GenericComparator<4>>;
  
    template class IndexIterator<GenericKey<8>, RID, GenericComparator<8>>;
  
    template class IndexIterator<GenericKey<16>, RID, GenericComparator<16>>;
  
    template class IndexIterator<GenericKey<32>, RID, GenericComparator<32>>;
  
    template class IndexIterator<GenericKey<64>, RID, GenericComparator<64>>;
  
  } // namespace bustub
  
  ```

  

- 第5关：B+树索引：Remove

  ### 任务和测试说明

    在成功实现B+树索引的插入功能后，请完成B+树索引的删除功能，这也是索引B+树的最后一个功能模块。  一颗完整的B+树由内部节点和叶子节点组成，随着记录的删除，节点不断合并减少，但仍需保持B+树的完整性和一致性。在本关卡中，B+树仅对外暴露Remove接口，即向B+树中删除特定记录。当删除特定记录时，首先从根节点进入B+树，通过内部节点的索引信息不断向下遍历，直至对应的叶子节点，之后删除该记录，删除后判断内部记录是否已小于最小值，是则开始进行树的调整。首先判断是否可以与相邻兄弟节点合并，如果可以合并兄弟节点，则合并后删除其在父节点中的索引，即递归进行元素删除操作，直至不再有合并发生；否则可以进行元素的调动，移动兄弟节点中一个元素补充到叶子节点中，并维持B+树的索引正确。在充分理解B+树的删除过程后，自上而下定义多个函数承载不同的子功能，并将待实现函数的功能以及整个流程中的函数调用关系和条件做明确注释说明，最后整合为删除功能，实现B+树的删减操作。  针对上述功能，设计测试流程以判断BPlusTree的删除功能是否达到预期结果。在该关卡中，删除的测试流程与插入的测试流程设计思路和整体结构相似，测试流程分为三个阶段，代表了B+树删减过程中的三个阶段，三个阶段均进行删除功能的验证，同时穿插B+树迭代器遍历数据进行数据完整性验证。 B+树当前仅包含根节点存储记录信息，深度为1。首先B+树初始化，指定缓冲区管理器以及当前阶数，并生成符合条件的B+树，从而方便后续进行删除操作，树结构正确性验证。进入第一阶段，在多次删除数据后观察根节点数据是否正常，并观察在删除全部数据后B+树是否置空。  B+树第一次合并，根节点更新，深度由2到1。生成符合条件的2层B+树，当前B+树叶子节点即将进入合并状态，并替换根节点，由于阶数与插入数据均确定，此时B+树的内部结构和数据应符合预期要求，将此时的树打印出来，与预期结果对比进行验证。  B+树包含大量记录，并开始不断删除记录，以大量数据覆盖删除过程中功能函数的所有路径，验证删除功能的健壮性。在这个阶段，不仅需要校验功能的完整性、数据的准确性，还会对内存管理进行验证，由于大量数据的删除，必然会出现缓冲区满和页面替换的情况，如果没有处理好页的获取与释放，就会导致缓冲区内存溢出，程序出错，因此也需要注意对缓冲区处理的评测。

  ### 相关变量声明

  ```
  //内部结点,叶结点,迭代器定义时可直接使用以下类型声明
  #define B_PLUS_TREE_LEAF_PAGE_TYPE BPlusTreeLeafPage<KeyType, ValueType, KeyComparator>
  #define B_PLUS_TREE_INTERNAL_PAGE BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator>
  #define INDEXITERATOR_TYPE IndexIterator<KeyType, ValueType, KeyComparator>
  //头页，用于存储metadata，比如记录索引根结点，表信息等等
  HeaderPage *header_page
  //缓冲区对象，负责特定页的获取
  BufferPoolManager *buffer_pool_manager
  ```

  ### 关卡内容

  请在b_plus_tree_delete.cpp文件中实现下列函数：

  ```
  bool IsEmpty() const;
  void Remove(const KeyType &key, Transaction *transaction = nullptr);
  template <typename N>bool CoalesceOrRedistribute(N *node, Transaction *transaction = nullptr);
  template <typename N>  bool FindSibling(N *node, N *&sibling);
  template <typename N>bool Coalesce(N **neighbor_node, N **node, BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator> **parent,int index, Transaction *transaction = nullptr);
  template <typename N>  void Redistribute(N *neighbor_node, N *node, int index);
  bool AdjustRoot(BPlusTreePage *node);
  void UpdateRootPageId(int insert_record = 0);
  ```

code:

```
#include "common/exception.h"
#include "common/rid.h"
#include "storage/index/b_plus_tree.h"
#include "storage/page/header_page.h"
#include <iostream>
#include <string>

namespace bustub
{
  INDEX_TEMPLATE_ARGUMENTS
  BPLUSTREE_TYPE::BPlusTree(std::string name, BufferPoolManager *buffer_pool_manager, const KeyComparator &comparator,
                            int leaf_max_size, int internal_max_size)
      : index_name_(std::move(name)),
        root_page_id_(INVALID_PAGE_ID),
        buffer_pool_manager_(buffer_pool_manager),
        comparator_(comparator),
        leaf_max_size_(leaf_max_size),
        internal_max_size_(internal_max_size) {}

  /*****************************************************************************
   * 删除
   *****************************************************************************/
  /*
   * 函数功能：
   *  在B+树中删除key对应的记录
   * 建议：
   *  1.若B+树为空直接返回
   *  2.通过上一个关卡实现的FindLeafPage(key)查找key值所在页并删除记录
   *  3.删除后需判断结点元素是否小于min_size,并调用CoalesceOrRedistribute()进行后续处理
   *  4.注意unpinPage，避免缓冲区内存泄露
   */
  INDEX_TEMPLATE_ARGUMENTS
  void BPLUSTREE_TYPE::Remove(const KeyType &key)
  {
    //并发索引，本实验暂不考虑
    std::lock_guard<std::mutex> lock(latch_);
    if (IsEmpty())
      return;
    Page *page = FindLeafPage(key);
    if (page == nullptr)
      return;
    B_PLUS_TREE_LEAF_PAGE_TYPE *leafPage = reinterpret_cast<B_PLUS_TREE_LEAF_PAGE_TYPE *>(page->GetData());
    leafPage->RemoveAndDeleteRecord(key, comparator_);
    if (leafPage->GetSize() < leafPage->GetMinSize())
    {
      CoalesceOrRedistribute(leafPage);
    }
    buffer_pool_manager_->UnpinPage(leafPage->GetPageId(), true);
  }

  /*
   * 函数功能：
   *  对元素个数小于Min_size的结点进行处理
   *      @param N *node 表示内部结点或叶结点
   *      @return: 若有结点合并，返回true，否则返回false
   * 建议：
   *  1.当node为根结点时，需要调用AdjustRoot()进行调整
   *  2.首先要通过调用FindSibling()找到兄弟结点
   *  3.如果两个结点的元素可以合并，则调用Coalesce()进行合并
   *  4.如果元素过多，无法合并，则调用Redistribute()进行结点元素的调整
   */
  INDEX_TEMPLATE_ARGUMENTS
  template <typename N>
  bool BPLUSTREE_TYPE::CoalesceOrRedistribute(N *node)
  {
    //如果可以合并：进行页的选择和合并
    //如果无法合并，则选择从其他页抽取一个结点，先找兄弟FindSibling
    if (node->IsRootPage())
    {
      //该函数可能递归调用至根结点，故需要对根结点进行特殊处理
      return AdjustRoot(node);
    }
    // Hint:	//进行if判断，保证在父页删除的key为父页的非首结点
    //根据node的位置，如果node处于首结点，则此时需要把后继页sibling合并到node中
    //否则，把node合并到sibling（前驱页）中
    N *siblingNode;
    FindSibling(node, siblingNode);
    // result 为true代表此时node为父页的首节点
    Page *page = buffer_pool_manager_->FetchPage(node->GetParentPageId());
    B_PLUS_TREE_INTERNAL_PAGE *parent_page = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(page->GetData());
    if (node->GetSize() + siblingNode->GetSize() <= node->GetMaxSize())
    {
      int flag = FindSibling(node, siblingNode);
      if (flag)
      {
        // node处于首节点
        int index = parent_page->ValueIndex(siblingNode->GetPageId());
        Coalesce(&node, &siblingNode, &parent_page, index);
      }
      else
      {
        int index = parent_page->ValueIndex(node->GetPageId());
        Coalesce(&siblingNode, &node, &parent_page, index);
      }
      buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), true);
      return true;
    }
    else
    {
      //无法合并
      int index = parent_page->ValueIndex(node->GetPageId());
      Redistribute(siblingNode, node, index);
      buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), false);
      return false;
    }
  }

  /*
   * 函数功能：
   *  对元素个数小于Min_size的根结点进行更新
   *      @return: 若有结点被删除，返回true，否则返回false
   * 建议：
   *  1.根结点可能是叶结点，也可能是内部结点，分开处理
   *  2.当根结点中最后一个元素被删除，此时B+树为空，调用UpdateRootPageId()更新根结点page_id
   *  3.当根结点中仅剩余一个元素，替换更新B+树的根结点
   *  4.注意unpinPage和deletePage
   */
  INDEX_TEMPLATE_ARGUMENTS
  bool BPLUSTREE_TYPE::AdjustRoot(BPlusTreePage *old_root_node)
  {
    if (old_root_node->IsLeafPage())
    {
      //此时root中size为0，且树中只有root，故直接删除结点，更新相关数据即可
      buffer_pool_manager_->UnpinPage(old_root_node->GetPageId(), false);
      buffer_pool_manager_->DeletePage(old_root_node->GetPageId());
      root_page_id_ = INVALID_PAGE_ID;
      UpdateRootPageId();
      return true;
    }
    if (old_root_node->GetSize() == 1)
    {
      //此时root中size为1，即根结点只有一个子页，原根结点可以被替代，故进行根结点的更新（根页作为内部页时最少需2个结点）
      B_PLUS_TREE_INTERNAL_PAGE *root = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(old_root_node);
      const page_id_t newRootId = root->RemoveAndReturnOnlyChild();
      root_page_id_ = newRootId;
      UpdateRootPageId();
      Page *page = buffer_pool_manager_->FetchPage(root_page_id_);
      assert(page != nullptr);
      B_PLUS_TREE_INTERNAL_PAGE *newRoot = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(page->GetData());
      newRoot->SetParentPageId(INVALID_PAGE_ID);
      buffer_pool_manager_->UnpinPage(root_page_id_, true);
      buffer_pool_manager_->UnpinPage(old_root_node->GetPageId(), false);
      buffer_pool_manager_->DeletePage(old_root_node->GetPageId());
    }
    return false;
  }

  /*
   * 函数功能：
   *  寻找node结点的兄弟结点sibling
   *      @return: 若兄弟结点为右结点，则返回true，左结点则为false
   * 建议：
   *  1.兄弟结点最好是索引在同一父节点内的结点
   *  2.注意unpinPage，避免缓冲区内存泄露
   */
  INDEX_TEMPLATE_ARGUMENTS
  template <typename N>
  bool BPLUSTREE_TYPE::FindSibling(N *node, N *&sibling)
  {
    //如果是node是父页的首结点，则从后继页抽一个，如果不是，则从前驱页抽一个。这样可以保证影响范围都是在同一个父页内，操作简单
    Page *page = buffer_pool_manager_->FetchPage(node->GetParentPageId());
    B_PLUS_TREE_INTERNAL_PAGE *parent_page = reinterpret_cast<B_PLUS_TREE_INTERNAL_PAGE *>(page->GetData());
    int index = parent_page->ValueIndex(node->GetPageId());
    int sIndex;
    if (index == 0)
    {
      sIndex = index + 1;
    }
    else
    {
      sIndex = index - 1;
    }
    Page *siblingPage = buffer_pool_manager_->FetchPage(parent_page->ValueAt(sIndex));
    sibling = reinterpret_cast<N *>(siblingPage->GetData());
    buffer_pool_manager_->UnpinPage(parent_page->GetPageId(), false);
    if (index == 0)
      return true;
    else
      return false;
  }
  /*
   * 函数功能：
   *  将node中的元素全部合并到neighbor_node中
   *      @param   neighbor_node      幸存结点
   *      @param   node               待合并结点
   *      @param   parent             二者的父结点
   *      @param   index              待合并结点在父结点中的索引
   *      @return: 若有结点被删除，返回true，否则返回false
   * 建议：
   *  1.node合并后需对父结点进行相关调整
   *  2.父结点元素被删除后，若小于Min_size则调用CoalesceOrRedistribute处理
   *  3.注意unpinPage和deletePage
   */
  INDEX_TEMPLATE_ARGUMENTS
  template <typename N>
  bool BPLUSTREE_TYPE::Coalesce(N **neighbor_node, N **node,
                                BPlusTreeInternalPage<KeyType, page_id_t, KeyComparator> **parent, int index)
  {
    assert((*node)->GetSize() + (*neighbor_node)->GetSize() <= (*node)->GetMaxSize());
    page_id_t node_id = (*node)->GetPageId();
    (*node)->MoveAllTo(*neighbor_node, buffer_pool_manager_);
    (*parent)->Remove(index);
    buffer_pool_manager_->UnpinPage(node_id, true);
    buffer_pool_manager_->UnpinPage((*neighbor_node)->GetPageId(), true);
    buffer_pool_manager_->DeletePage(node_id);
    //当内部页中size过小时或者仅剩余一个有效结点时，递归触发CoalesceOrRedistribute函数，对当前结点进行处理
    if (((*parent)->GetSize() == 2) || ((*parent)->GetMinSize() > (*parent)->GetSize()))
      return CoalesceOrRedistribute(*parent);
    return false;
  }

  /*
   * 函数功能：
   *  将node中的元素移动到neighbor_node中
   * 建议：
   *  1.若index为0，将neighbor_node首元素移动到node尾部
   *  否则将neighbor_node的尾元素移动到node首部
   *  2.注意unpinPage，避免缓冲区内存泄露
   */
  INDEX_TEMPLATE_ARGUMENTS
  template <typename N>
  void BPLUSTREE_TYPE::Redistribute(N *neighbor_node, N *node, int index)
  {
    if (index == 0)
    {
      neighbor_node->MoveFirstToEndOf(node, buffer_pool_manager_);
    }
    else
    {
      neighbor_node->MoveLastToFrontOf(node, buffer_pool_manager_);
    }
    buffer_pool_manager_->UnpinPage(neighbor_node->GetPageId(), true);
    buffer_pool_manager_->UnpinPage(node->GetPageId(), true);
  }

  /*
   * 函数功能：
   *  当B+树根结点发生变化时，调用该函数在header_page中对根结点ID进行更新
   *      @param insert_record 缺省时insert_record为0
   */
  INDEX_TEMPLATE_ARGUMENTS
  void BPLUSTREE_TYPE::UpdateRootPageId(int insert_record)
  {
    HeaderPage *header_page = static_cast<HeaderPage *>(buffer_pool_manager_->FetchPage(HEADER_PAGE_ID));
    if (insert_record != 0)
    {
      // create a new record<index_name + root_page_id> in header_page
      header_page->InsertRecord(index_name_, root_page_id_);
    }
    else
    {
      // update root_page_id in header_page
      header_page->UpdateRecord(index_name_, root_page_id_);
    }
    buffer_pool_manager_->UnpinPage(HEADER_PAGE_ID, true);
  }

  template class BPlusTree<GenericKey<4>, RID, GenericComparator<4>>;
  template class BPlusTree<GenericKey<8>, RID, GenericComparator<8>>;
  template class BPlusTree<GenericKey<16>, RID, GenericComparator<16>>;
  template class BPlusTree<GenericKey<32>, RID, GenericComparator<32>>;
  template class BPlusTree<GenericKey<64>, RID, GenericComparator<64>>;

} // namespace bustub

```

