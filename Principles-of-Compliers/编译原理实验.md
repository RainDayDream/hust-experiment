# 编译原理实验

2020级编译原理实验  2023.4-2023.6

## 实验一 熟悉环境

### 1-1 编译工具链的使用

1. **gcc的使用**

   - `-E` 只执行预处理
   - `-c` 编译或汇编源文件，不执行链接
   - `-S` 完成编译但不执行汇编，产生汇编文件
   - `-o file` 指定输出的文件为file。如果未指定该选项，在Linux下生成的可执行代码将被命名为缺省值a.out。指定输出文件名时，应使用缺省的后缀：预处理后：.i； 汇编代码：.s；目标代码.o等。
   - `-DSOMETHING` 宏定义,即预处理语句“#define SOMETHING”中的宏SOMETHING。
   - `-I` 指定头文件的搜索路径
   - `-O` 批定优化级别，如：-O2,-O3等。

   ```
   #用 gcc 编译器，连编def-test.c, alibaba.c，生成def-test二进制可执行代码。通过在编译命令行加适当的参数，
   # 使生成的程序能形成Alibaba和Bili两个人的对话：
   gcc def-test.c alibaba.c -D BILIBILI -o def-test
   ```

2. **clang的使用**

   Clang的命令行编译选项基本继承了gcc的大部分编译选项，如：-S, -o, -O, -c等。它也有一些gcc不支持的编译选项，比如**交叉编译，通过指定-target参数，可以在X86的平台将C源程序“翻译”成其它平台下的汇编代码或二进制代码。**

   ```
   # 请用 用clang编译器把bar.c“翻译”成优化的(优化级别O2)armv7架构，linux系统，符合gnueabihf嵌入式二进制接口规则，
   # 并支持arm硬浮点的汇编代码（程序中并没有浮点数）。汇编代码文件名为bar.clang.arm.s
   # 请使用恰当的编译选项以完成上述任务：
   clang -S -target armv7-linux-gnueabihf bar.c -O2 -o bar.clang.arm.s
   ```

3. **交叉编译器arm-linux-gnueabihf-gcc的使用**

   ```
   # 用arm-linux-gnueabihf-gcc 将iplusf.c编译成arm汇编代码iplusf.arm.s
   arm-linux-gnueabihf-gcc -S iplusf.c -o iplusf.arm.s
   # 再次用arm-linux-gnueabihf-gcc 汇编iplusf.arm.s，同时连接SysY2022的运行时库sylib.a，生成arm的可执行代码iplusf.arm
   arm-linux-gnueabihf-gcc  iplusf.arm.s sylib.a -o iplusf.arm
   # 用qemu-arm运行iplusf.arm,iplusf.arm前有空格
   qemu-arm -L /usr/arm-linux-gnueabihf/ iplusf.arm
   ```

4. **make的使用**

   Makefile文件由一系列规则构成。每条规则的形式如下：

   ```
   target ... : prerequisites ...    
   	command    ...
   
   objects:= main.cc helloworld.cc
   
   helloworld: main.cc
   	clang++ -o helloworld -I include main.cc helloworld.cc -Wall -g -O2 -std=c++17
   helloworld.cc: helloworld.hh
   	clang++ -c helloworld.cc
   ```

### 1-2 sys语言与运行库

任务要求：采用sys语言编写一个程序，使得程序可以实现以下功能：

​	给定一个数组 prices ，它的第 i 个元素 prices[i] 表示一支给定股票第 i 个交易日的价格(假定股价是整数)。你只能选择某个交易日买入这只股票，并选择在未来的另一个交易日卖出该股票。设计一个算法来计算你所能获取的最大利润，并返回这个最大利润值。如果你不能获取任何利润，返回 0 。

```
const int N = 10;
int prices[N]; 

// 请完成函数maxProfit(),其输入为股价数组，输出为可获得的最大利润 
int maxProfit(int prices[]){
    // ----------  开始
    int res=0;
    int min=prices[0];
    int i=1;
    while(i<N){
        if(prices[i]<min){
            min=prices[i];
        }
        else{
            if(prices[i]-min>res) res=prices[i]-min;
        }
        i=i+1;
    }
    return res;



    // ----------- 结束
}

// main()接收连续N个交易日的股价输入并存入数组prices[],
// 接着调用maxProfit()求可能的最大利润，然后输出该值，并换行。
int main(){
    // 股价数组的输入：
    int i=0;

    while(i<N)
    {
        prices[i]=getint();
        i=i+1;
    }


    int best = maxProfit(prices);
    //结果输出：
    putf("%d\n",best);
    return 1;
}
```

### 1-3 arm汇编

实验任务：arm汇编实现冒泡函数

​	main调用bubblesort之前，将数组arr的首地址保存在寄存器r0中，数组元素的个数n保存在寄存器r1中。bubblesort返回值为0，由r0传递（调用者借返回值 给循环变量赋初值 ）。

```
   	.arch armv7-a
	.text
	.global	bubblesort
	.syntax unified
	.thumb
	.thumb_func
bubblesort:

    push {r0,r1,r2,r3,r4,r5,r6,r7} @保护寄存器

    sub r2,r1,#1
    extern_loop: @外层循环
        mov r3,#0
        mov r4,r0
        inner_loop: @内层循环
            @add r5,r4,#4
            ldr r6,[r4]
            ldr r7,[r4,#4]
            cmp r6,r7
            ble skip_swap
            @进行交换
            str r6,[r4,#4]
            str r7,[r4]
            skip_swap:
                add r3,r3,#1
                add r4,r4,#4
                cmp r3,r2
                blt inner_loop
        sub r2,r2,#1
        cmp r2,#0
        bgt extern_loop
    pop {r0,r1,r2,r3,r4,r5,r6,r7}
    mov r0,#0

	bx	lr

```

### 1-4 riscv汇编实现排序

思路和arm的一样

```
        .text
        .align  1
        .globl  bubblesort
        .type   bubblesort, @function
bubblesort:

        
        addi t0,a1,-1
        extern_loop:
                andi t1,t1,0
                ori t2,a0,0
                inner_loop:
                      lw t3,0(t2)
                      lw t4,4(t2)
                      ble t3,t4,skip_swap
                      sw t3,4(t2)
                      sw t4,0(t2)
                      skip_swap:
                        addi t1,t1,1
                        addi t2,t2,4
                        blt t1,t0,inner_loop  
                addi t0,t0,-1
                blt zero,t0,extern_loop
.L2:
        li      a0,0
        ret
        .size   bubblesort, .-bubblesort

```

## 实训2 词法分析

三选一即可（flex+c/flex+c++/antlr+c++）

### flex+C/flex+C++

```
/*标识符、整数、浮点数*/
[a-z_A-Z][a-z_A-Z0-9]* {printf("%s : ID\n", yytext); return ID; }
[1-9][0-9]*|0[0-7]*|0[xX][0-9a-fA-F]+ {printf("%s : INT_LIT\n", yytext); return INT_LIT; }
[0-9]+\.[0-9]+f|[0-9]+[\.]*[0-9]*[Ee][+-][0-9]+f  {printf("%s : FLOAT_LIT\n", yytext); return FLOAT_LIT; }

/*出错处理*/
[0-9][a-z_A-Z][a-z_A-Z0-9]*|0[0-9]*[8-9a-fA-F][0-9]* {printf("Lexical error - line %d : %s\n",yylineno,yytext);return LEX_ERR;}
```

## 实验三 语法分析

三选一

### flex/bison+c

将产生式转换成bison的语法规则

```
Stmt : LVal ASSIGN Exp SEMICOLON { $$ = new_node(Stmt,$1,NULL,$3,AssignStmt,0,NULL,NonType);}
    | Exp SEMICOLON { $$ = new_node(Stmt,NULL,NULL,$1,ExpStmt,0,NULL,NonType);}
    | SEMICOLON { $$ = new_node(Stmt,NULL,NULL,NULL,BlankStmt,0,NULL,NonType);}
    | Block { $$ = new_node(Stmt,NULL,NULL,$1,Block,0,NULL,NonType);}
    | IF LP Cond RP Stmt ELSE Stmt  { $$ = new_node(Stmt,$3,$5,$7,IfElseStmt,0,NULL,NonType);}
    | IF LP Cond RP Stmt { $$ = new_node(Stmt,$3,NULL,$5,IfStmt,0,NULL,NonType);}
    | WHILE LP Cond RP Stmt { $$ = new_node(Stmt,$3,NULL,$5,WhileStmt,0,NULL,NonType);}
    | BREAK SEMICOLON { $$ = new_node(Stmt,NULL,NULL,NULL,BreakStmt,0,NULL,NonType);}
    | CONTINUE SEMICOLON { $$ = new_node(Stmt,NULL,NULL,NULL,ContinueStmt,0,NULL,NonType);}
    | RETURN Exp SEMICOLON { $$ = new_node(Stmt,NULL,NULL,$2,ReturnStmt,0,NULL,NonType);}
    | RETURN SEMICOLON { $$ = new_node(Stmt,NULL,NULL,NULL,BlankReturnStmt,0,NULL,NonType);}
    ;
```

## 实验四 生成LLVM IR中间代码

简单地説，你需要作的工作是：

1. 在visit(lVal)之前通过全局临时变量，传递信息，表示当前的lVal是赋值语句左值，不是表达式。
2. 在visit(lVal)之后从recentVal取左值的Value(一个Value类的对象)。
3. 在visit(exp)后，从recentVal取右值的Value(也是一个Value类的对象).
4. 检查赋值语句左值和右值的类型，必要时作类型转换。LLVM IR是强类型语言，所有指令的两个操作数必须是同一类型。比如： 

- 当左值为指向i32的指针而右值是一float类型的值时，右值应当转为i32。
- 当左值为指向float的指针而右值是一个int类型的值时，右值应当转为float。 类型转换函数都有对应的方法，如：

```
 IRStmtBuilder::create_fptosi(Value *val, Type *ty)  
```

5. 调用IRStmtBuilder::create_store(Value *val, Value *ptr)方法生成store指令。

注意两个操作数别弄反方向，虽然都是Value类型。**注：赋值语句的左值是一个指针(变量的地址)，如i32*,float*；右值是一个值，类型为i32或float。**在genIR实例化时即已创建IRStmtmBuilder类的builer对象。可直接调用builder->create_xxx方法创建各种语句。

```
//****************************************************************************
//* 你需要完成这个visit()方法
//****************************************************************************
void GenIR::visit(StmtAST &ast) {
    switch (ast.sType) {
        case SEMI:
            break;
        case ASS: {
            // ******************* 代码填写处
            requireLVal = true;  //表示当前的lVal是赋值语句左值，不是表达式。
            ast.lVal->accept(*this);//取左值的Value
            auto var = recentVal;
            is_single_exp = true;//作为单独的exp语句出现，形如 "exp;"
            ast.exp->accept(*this);//取右值的Value
            auto expval = recentVal;
            if (var->type_->tid_ == Type::FloatTyID && expval->type_->tid_ == Type::IntegerTyID) 
            {
                //当左值为指向float的指针而右值是一个int类型的值时，右值应当转为float。
                expval = builder->create_sitofp(expval,FLOAT_T);
            }
            else if (var->type_->tid_ == Type::IntegerTyID && expval->type_->tid_ == Type::FloatTyID) 
            {
                //当左值为指向i32的指针而右值是一float类型的值时，右值应当转为i32。
                expval = builder->create_fptosi(expval, INT32_T);
            }
            builder->create_store(expval, var);//创建语句
            // ******************* 代码结束
            break;
        }
        case EXP:
            is_single_exp = true;
            ast.exp->accept(*this);
            is_single_exp = false;
            break;
        case CONT:
            builder->create_br(whileCondBB);
            has_br = true;
            break;
        case BRE:
            builder->create_br(whileFalseBB);
            has_br = true;
            break;
        case RET:
            ast.returnStmt->accept(*this);
            break;
        case BLK:
            ast.block->accept(*this);
            break;
        case SEL:
            ast.selectStmt->accept(*this);
            break;
        case ITER:
            ast.iterationStmt->accept(*this);
            break;
    }

}
```

## 实验五 使用 LLVM 工具链生成目标代码

### arm平台

```
#include "codegen.h"
#include <memory>
#include <optional>
#include <string>

using namespace llvm;
using namespace llvm::sys;

namespace codegen {
bool codeGenerate(const std::string &ir_filename,
                  const CodeGenFileType &gen_filetype) {
  SMDiagnostic error_smdiagnostic;
  LLVMContext context;
  std::unique_ptr<Module> module =
      parseIRFile(ir_filename, error_smdiagnostic, context);

  if (!module) {
    error_smdiagnostic.print(ir_filename.c_str(), errs());
    return false;
  }

  // Initialize the target registry etc. 
  // *******************************************************************
  // 补充代码1 - 初始化目标


  InitializeAllTargetInfos();
  InitializeAllTargets();
  InitializeAllTargetMCs();
  InitializeAllAsmParsers();
  InitializeAllAsmPrinters();

  //auto target_triple = module->getTargetTriple();
  //auto target_triple = getDefaultTargetTriple();
  //auto target_triple = "riscv64-unknown-elf";
  //auto target_triple = "armv7-unknown-linux-gnueagihf";
  
  // **********************************************************************
  // 补充代码2 - 指定目标平台

  auto target_triple = "armv7-unknown-linux-gnueabihf";
  module->setTargetTriple(target_triple);

  std::string error_string;
  auto target = TargetRegistry::lookupTarget(target_triple, error_string);

  // Print an error and exit if we couldn't find the requested target.
  // This generally occurs if we've forgotten to initialise the
  // TargetRegistry or we have a bogus target triple.
  if (!target) {
    errs() << error_string;
    return 1;
  }

  auto cpu = "generic";
  // auto cpu = "";
  auto features = "";

  TargetOptions opt;
  auto RM = Optional<Reloc::Model>();
  auto TheTargetMachine =
      target->createTargetMachine(target_triple, cpu, features, opt, RM);

  module->setDataLayout(TheTargetMachine->createDataLayout());

  // *************************************************************************
  // 补充代码3 - 初始化addPassesToEmitFile()的参数，请按以下顺序
  // (1) 调用getGenFilename()函数，获得要写入的目标代码文件名filename
  // (2) 实例化raw_fd_ostream类的对象dest。构造函数： 
  //      raw_fd_ostream(StringRef Filename, std::error_code &EC, sys::fs::OpenFlags Flags);
  //    Flags置sys::fs::OF_None
  //    注意EC是一个std::error_code类型的对象，你需要事先声明EC，
  //    通常还应在调用函数后检查EC，if (EC) 则表明有错误发生(无法创建目标文件)，此时应该输出提示信息后return 1
  // (3) 实例化legacy::PassManager类的对象pass
  // (4) 为file_type赋初值。

  //(1)
  auto filename = getGenFilename(ir_filename,gen_filetype);
  //(2)
  std::error_code EC;
  raw_fd_ostream dest(filename, EC, sys::fs::OF_None);
  if(EC){
    return 1;
  }
  //(3)
  legacy::PassManager pass;
  //(4)
  auto file_type = gen_filetype;
  

  if (TheTargetMachine->addPassesToEmitFile(pass, dest, nullptr, file_type)) {
    errs() << "TheTargetMachine can't emit a file of this type";
    return 1;
  }

  pass.run(*module);
  dest.flush();
  return true;
}

std::string getGenFilename(const std::string &ir_filename,
                           const CodeGenFileType &gen_filetype) {
  if (gen_filetype == CGFT_Null) {
    return nullptr;
  }
  return ir_filename.substr(0, ir_filename.find(".")) +
         (gen_filetype == CGFT_AssemblyFile ? ".s" : ".o");
}
} // namespace codegen
```

### riscv平台

```
#include "codegen.h"
#include <memory>
#include <optional>
#include <string>

using namespace llvm;
using namespace llvm::sys;

namespace codegen {
bool codeGenerate(const std::string &ir_filename,
                  const CodeGenFileType &gen_filetype) {
  SMDiagnostic error_smdiagnostic;
  LLVMContext context;
  std::unique_ptr<Module> module =
      parseIRFile(ir_filename, error_smdiagnostic, context);

  if (!module) {
    error_smdiagnostic.print(ir_filename.c_str(), errs());
    return false;
  }

  // Initialize the target registry etc. 
  // *******************************************************************
  // 补充代码1 - 初始化目标

  InitializeAllTargetInfos();
  InitializeAllTargets();
  InitializeAllTargetMCs();
  InitializeAllAsmParsers();
  InitializeAllAsmPrinters();

 
  //auto target_triple = module->getTargetTriple();
  //auto target_triple = getDefaultTargetTriple();
  //auto target_triple = "riscv64-unknown-elf";
  //auto target_triple = "armv7-unknown-linux-gnueagihf";
  
  // **********************************************************************
  // 补充代码2 - 指定目标平台

/*修改处*/
  auto target_triple = "riscv64-unknown-elf";
  module->setTargetTriple(target_triple);

  std::string error_string;
  auto target = TargetRegistry::lookupTarget(target_triple, error_string);

  // Print an error and exit if we couldn't find the requested target.
  // This generally occurs if we've forgotten to initialise the
  // TargetRegistry or we have a bogus target triple.
  if (!target) {
    errs() << error_string;
    return 1;
  }

/*修改处*/
  auto cpu = "generic-rv64";
  // auto cpu = "";
  auto features = "";

  TargetOptions opt;
  auto RM = Optional<Reloc::Model>();
  auto TheTargetMachine =
      target->createTargetMachine(target_triple, cpu, features, opt, RM);

  module->setDataLayout(TheTargetMachine->createDataLayout());

  // *************************************************************************
  // 补充代码3 - 初始化addPassesToEmitFile()的参数，请按以下顺序
  // (1) 调用getGenFilename()函数，获得要写入的目标代码文件名filename
  // (2) 实例化raw_fd_ostream类的对象dest。构造函数： 
  //      raw_fd_ostream(StringRef Filename, std::error_code &EC, sys::fs::OpenFlags Flags);
  //    Flags置sys::fs::OF_None
  //    注意EC是一个std::error_code类型的对象，你需要事先声明EC，
  //    通常还应在调用函数后检查EC，if (EC) 则表明有错误发生(无法创建目标文件)，此时应该输出提示信息后return 1
  // (3) 实例化legacy::PassManager类的对象pass
  // (4) 为file_type赋初值。

   //(1)
  auto filename = getGenFilename(ir_filename,gen_filetype);
  //(2)
  std::error_code EC;
  raw_fd_ostream dest(filename, EC, sys::fs::OF_None);
  if(EC){
    return 1;
  }
  //(3)
  legacy::PassManager pass;
  //(4)
  auto file_type = gen_filetype;
  


  if (TheTargetMachine->addPassesToEmitFile(pass, dest, nullptr, file_type)) {
    errs() << "TheTargetMachine can't emit a file of this type";
    return 1;
  }

  pass.run(*module);
  dest.flush();
  return true;
}

std::string getGenFilename(const std::string &ir_filename,
                           const CodeGenFileType &gen_filetype) {
  if (gen_filetype == CGFT_Null) {
    return nullptr;
  }
  return ir_filename.substr(0, ir_filename.find(".")) +
         (gen_filetype == CGFT_AssemblyFile ? ".s" : ".o");
}
} // namespace codegen
```

